{"ast":null,"code":"var camelCase = require('camelcase');\n\nvar decamelize = require('decamelize');\n\nvar path = require('path');\n\nvar tokenizeArgString = require('./lib/tokenize-arg-string');\n\nvar util = require('util');\n\nfunction parse(args, opts) {\n  if (!opts) opts = {}; // allow a string argument to be passed in rather\n  // than an argv array.\n\n  args = tokenizeArgString(args); // aliases might have transitive relationships, normalize this.\n\n  var aliases = combineAliases(opts.alias || {});\n  var configuration = Object.assign({\n    'short-option-groups': true,\n    'camel-case-expansion': true,\n    'dot-notation': true,\n    'parse-numbers': true,\n    'boolean-negation': true,\n    'negation-prefix': 'no-',\n    'duplicate-arguments-array': true,\n    'flatten-duplicate-arrays': true,\n    'populate--': false,\n    'combine-arrays': false,\n    'set-placeholder-key': false,\n    'halt-at-non-option': false,\n    'strip-aliased': false,\n    'strip-dashed': false,\n    'unknown-options-as-args': false\n  }, opts.configuration);\n  var defaults = opts.default || {};\n  var configObjects = opts.configObjects || [];\n  var envPrefix = opts.envPrefix;\n  var notFlagsOption = configuration['populate--'];\n  var notFlagsArgv = notFlagsOption ? '--' : '_';\n  var newAliases = {}; // allow a i18n handler to be passed in, default to a fake one (util.format).\n\n  var __ = opts.__ || util.format;\n\n  var error = null;\n  var flags = {\n    aliases: {},\n    arrays: {},\n    bools: {},\n    strings: {},\n    numbers: {},\n    counts: {},\n    normalize: {},\n    configs: {},\n    nargs: {},\n    coercions: {},\n    keys: []\n  };\n  var negative = /^-[0-9]+(\\.[0-9]+)?/;\n  var negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');\n  [].concat(opts.array).filter(Boolean).forEach(function (opt) {\n    var key = opt.key || opt; // assign to flags[bools|strings|numbers]\n\n    const assignment = Object.keys(opt).map(function (key) {\n      return {\n        boolean: 'bools',\n        string: 'strings',\n        number: 'numbers'\n      }[key];\n    }).filter(Boolean).pop(); // assign key to be coerced\n\n    if (assignment) {\n      flags[assignment][key] = true;\n    }\n\n    flags.arrays[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.boolean).filter(Boolean).forEach(function (key) {\n    flags.bools[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.string).filter(Boolean).forEach(function (key) {\n    flags.strings[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.number).filter(Boolean).forEach(function (key) {\n    flags.numbers[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.count).filter(Boolean).forEach(function (key) {\n    flags.counts[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.normalize).filter(Boolean).forEach(function (key) {\n    flags.normalize[key] = true;\n    flags.keys.push(key);\n  });\n  Object.keys(opts.narg || {}).forEach(function (k) {\n    flags.nargs[k] = opts.narg[k];\n    flags.keys.push(k);\n  });\n  Object.keys(opts.coerce || {}).forEach(function (k) {\n    flags.coercions[k] = opts.coerce[k];\n    flags.keys.push(k);\n  });\n\n  if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n    ;\n    [].concat(opts.config).filter(Boolean).forEach(function (key) {\n      flags.configs[key] = true;\n    });\n  } else {\n    Object.keys(opts.config || {}).forEach(function (k) {\n      flags.configs[k] = opts.config[k];\n    });\n  } // create a lookup table that takes into account all\n  // combinations of aliases: {f: ['foo'], foo: ['f']}\n\n\n  extendAliases(opts.key, aliases, opts.default, flags.arrays); // apply default values to all aliases.\n\n  Object.keys(defaults).forEach(function (key) {\n    (flags.aliases[key] || []).forEach(function (alias) {\n      defaults[alias] = defaults[key];\n    });\n  });\n  var argv = {\n    _: []\n  };\n  var notFlags = [];\n\n  for (var i = 0; i < args.length; i++) {\n    var arg = args[i];\n    var broken;\n    var key;\n    var letters;\n    var m;\n    var next;\n    var value;\n\n    if (isUnknownOptionAsArg(arg)) {\n      argv._.push(arg); // -- separated by =\n\n    } else if (arg.match(/^--.+=/) || !configuration['short-option-groups'] && arg.match(/^-.+=/)) {\n      // Using [\\s\\S] instead of . because js doesn't support the\n      // 'dotall' regex modifier. See:\n      // http://stackoverflow.com/a/1068308/13216\n      m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/); // nargs format = '--f=monkey washing cat'\n\n      if (checkAllAliases(m[1], flags.nargs)) {\n        args.splice(i + 1, 0, m[2]);\n        i = eatNargs(i, m[1], args); // arrays format = '--f=a b c'\n      } else if (checkAllAliases(m[1], flags.arrays)) {\n        args.splice(i + 1, 0, m[2]);\n        i = eatArray(i, m[1], args);\n      } else {\n        setArg(m[1], m[2]);\n      }\n    } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n      key = arg.match(negatedBoolean)[1];\n      setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false); // -- separated by space.\n    } else if (arg.match(/^--.+/) || !configuration['short-option-groups'] && arg.match(/^-[^-]+/)) {\n      key = arg.match(/^--?(.+)/)[1]; // nargs format = '--foo a b c'\n      // should be truthy even if: flags.nargs[key] === 0\n\n      if (checkAllAliases(key, flags.nargs) !== false) {\n        i = eatNargs(i, key, args); // array format = '--foo a b c'\n      } else if (checkAllAliases(key, flags.arrays)) {\n        i = eatArray(i, key, args);\n      } else {\n        next = args[i + 1];\n\n        if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n          setArg(key, next);\n          i++;\n        } else if (/^(true|false)$/.test(next)) {\n          setArg(key, next);\n          i++;\n        } else {\n          setArg(key, defaultValue(key));\n        }\n      } // dot-notation flag separated by '='.\n\n    } else if (arg.match(/^-.\\..+=/)) {\n      m = arg.match(/^-([^=]+)=([\\s\\S]*)$/);\n      setArg(m[1], m[2]); // dot-notation flag separated by space.\n    } else if (arg.match(/^-.\\..+/)) {\n      next = args[i + 1];\n      key = arg.match(/^-(.\\..+)/)[1];\n\n      if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n        setArg(key, next);\n        i++;\n      } else {\n        setArg(key, defaultValue(key));\n      }\n    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n      letters = arg.slice(1, -1).split('');\n      broken = false;\n\n      for (var j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2);\n\n        if (letters[j + 1] && letters[j + 1] === '=') {\n          value = arg.slice(j + 3);\n          key = letters[j]; // nargs format = '-f=monkey washing cat'\n\n          if (checkAllAliases(key, flags.nargs)) {\n            args.splice(i + 1, 0, value);\n            i = eatNargs(i, key, args); // array format = '-f=a b c'\n          } else if (checkAllAliases(key, flags.arrays)) {\n            args.splice(i + 1, 0, value);\n            i = eatArray(i, key, args);\n          } else {\n            setArg(key, value);\n          }\n\n          broken = true;\n          break;\n        }\n\n        if (next === '-') {\n          setArg(letters[j], next);\n          continue;\n        } // current letter is an alphabetic character and next value is a number\n\n\n        if (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n          setArg(letters[j], next);\n          broken = true;\n          break;\n        }\n\n        if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          setArg(letters[j], next);\n          broken = true;\n          break;\n        } else {\n          setArg(letters[j], defaultValue(letters[j]));\n        }\n      }\n\n      key = arg.slice(-1)[0];\n\n      if (!broken && key !== '-') {\n        // nargs format = '-f a b c'\n        // should be truthy even if: flags.nargs[key] === 0\n        if (checkAllAliases(key, flags.nargs) !== false) {\n          i = eatNargs(i, key, args); // array format = '-f a b c'\n        } else if (checkAllAliases(key, flags.arrays)) {\n          i = eatArray(i, key, args);\n        } else {\n          next = args[i + 1];\n\n          if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n            setArg(key, next);\n            i++;\n          } else if (/^(true|false)$/.test(next)) {\n            setArg(key, next);\n            i++;\n          } else {\n            setArg(key, defaultValue(key));\n          }\n        }\n      }\n    } else if (arg === '--') {\n      notFlags = args.slice(i + 1);\n      break;\n    } else if (configuration['halt-at-non-option']) {\n      notFlags = args.slice(i);\n      break;\n    } else {\n      argv._.push(maybeCoerceNumber('_', arg));\n    }\n  } // order of precedence:\n  // 1. command line arg\n  // 2. value from env var\n  // 3. value from config file\n  // 4. value from config objects\n  // 5. configured default value\n\n\n  applyEnvVars(argv, true); // special case: check env vars that point to config file\n\n  applyEnvVars(argv, false);\n  setConfig(argv);\n  setConfigObjects();\n  applyDefaultsAndAliases(argv, flags.aliases, defaults);\n  applyCoercions(argv);\n  if (configuration['set-placeholder-key']) setPlaceholderKeys(argv); // for any counts either not in args or without an explicit default, set to 0\n\n  Object.keys(flags.counts).forEach(function (key) {\n    if (!hasKey(argv, key.split('.'))) setArg(key, 0);\n  }); // '--' defaults to undefined.\n\n  if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];\n  notFlags.forEach(function (key) {\n    argv[notFlagsArgv].push(key);\n  });\n\n  if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n    Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\n      delete argv[key];\n    });\n  }\n\n  if (configuration['strip-aliased']) {\n    // XXX Switch to [].concat(...Object.values(aliases)) once node.js 6 is dropped\n    ;\n    [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\n      if (configuration['camel-case-expansion']) {\n        delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')];\n      }\n\n      delete argv[alias];\n    });\n  } // how many arguments should we consume, based\n  // on the nargs option?\n\n\n  function eatNargs(i, key, args) {\n    var ii;\n    const toEat = checkAllAliases(key, flags.nargs);\n\n    if (toEat === 0) {\n      setArg(key, defaultValue(key));\n      return i;\n    } // nargs will not consume flag arguments, e.g., -abc, --foo,\n    // and terminates when one is observed.\n\n\n    var available = 0;\n\n    for (ii = i + 1; ii < args.length; ii++) {\n      if (!args[ii].match(/^-[^0-9]/) || isUnknownOptionAsArg(args[ii])) available++;else break;\n    }\n\n    if (available < toEat) error = Error(__('Not enough arguments following: %s', key));\n    const consumed = Math.min(available, toEat);\n\n    for (ii = i + 1; ii < consumed + i + 1; ii++) {\n      setArg(key, args[ii]);\n    }\n\n    return i + consumed;\n  } // if an option is an array, eat all non-hyphenated arguments\n  // following it... YUM!\n  // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n\n\n  function eatArray(i, key, args) {\n    let argsToSet = [];\n    let next = args[i + 1];\n\n    if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {\n      argsToSet.push(true);\n    } else if (isUndefined(next) || /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {\n      // for keys without value ==> argsToSet remains an empty []\n      // set user default value, if available\n      if (defaults.hasOwnProperty(key)) {\n        argsToSet.push(defaults[key]);\n      }\n    } else {\n      for (var ii = i + 1; ii < args.length; ii++) {\n        next = args[ii];\n        if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break;\n        i = ii;\n        argsToSet.push(processValue(key, next));\n      }\n    }\n\n    setArg(key, argsToSet);\n    return i;\n  }\n\n  function setArg(key, val) {\n    if (/-/.test(key) && configuration['camel-case-expansion']) {\n      var alias = key.split('.').map(function (prop) {\n        return camelCase(prop);\n      }).join('.');\n      addNewAlias(key, alias);\n    }\n\n    var value = processValue(key, val);\n    var splitKey = key.split('.');\n    setKey(argv, splitKey, value); // handle populating aliases of the full key\n\n    if (flags.aliases[key] && flags.aliases[key].forEach) {\n      flags.aliases[key].forEach(function (x) {\n        x = x.split('.');\n        setKey(argv, x, value);\n      });\n    } // handle populating aliases of the first element of the dot-notation key\n\n\n    if (splitKey.length > 1 && configuration['dot-notation']) {\n      ;\n      (flags.aliases[splitKey[0]] || []).forEach(function (x) {\n        x = x.split('.'); // expand alias with nested objects in key\n\n        var a = [].concat(splitKey);\n        a.shift(); // nuke the old key.\n\n        x = x.concat(a);\n        setKey(argv, x, value);\n      });\n    } // Set normalize getter and setter when key is in 'normalize' but isn't an array\n\n\n    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n      var keys = [key].concat(flags.aliases[key] || []);\n      keys.forEach(function (key) {\n        argv.__defineSetter__(key, function (v) {\n          val = path.normalize(v);\n        });\n\n        argv.__defineGetter__(key, function () {\n          return typeof val === 'string' ? path.normalize(val) : val;\n        });\n      });\n    }\n  }\n\n  function addNewAlias(key, alias) {\n    if (!(flags.aliases[key] && flags.aliases[key].length)) {\n      flags.aliases[key] = [alias];\n      newAliases[alias] = true;\n    }\n\n    if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n      addNewAlias(alias, key);\n    }\n  }\n\n  function processValue(key, val) {\n    // strings may be quoted, clean this up as we assign values.\n    if (typeof val === 'string' && (val[0] === \"'\" || val[0] === '\"') && val[val.length - 1] === val[0]) {\n      val = val.substring(1, val.length - 1);\n    } // handle parsing boolean arguments --foo=true --bar false.\n\n\n    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n      if (typeof val === 'string') val = val === 'true';\n    }\n\n    var value = Array.isArray(val) ? val.map(function (v) {\n      return maybeCoerceNumber(key, v);\n    }) : maybeCoerceNumber(key, val); // increment a count given as arg (either no value or value parsed as boolean)\n\n    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n      value = increment;\n    } // Set normalized value when key is in 'normalize' and in 'arrays'\n\n\n    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n      if (Array.isArray(val)) value = val.map(path.normalize);else value = path.normalize(val);\n    }\n\n    return value;\n  }\n\n  function maybeCoerceNumber(key, value) {\n    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n      const shouldCoerceNumber = isNumber(value) && configuration['parse-numbers'] && Number.isSafeInteger(Math.floor(value));\n      if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) value = Number(value);\n    }\n\n    return value;\n  } // set args from config.json file, this should be\n  // applied last so that defaults can be applied.\n\n\n  function setConfig(argv) {\n    var configLookup = {}; // expand defaults/aliases, in-case any happen to reference\n    // the config.json file.\n\n    applyDefaultsAndAliases(configLookup, flags.aliases, defaults);\n    Object.keys(flags.configs).forEach(function (configKey) {\n      var configPath = argv[configKey] || configLookup[configKey];\n\n      if (configPath) {\n        try {\n          var config = null;\n          var resolvedConfigPath = path.resolve(process.cwd(), configPath);\n\n          if (typeof flags.configs[configKey] === 'function') {\n            try {\n              config = flags.configs[configKey](resolvedConfigPath);\n            } catch (e) {\n              config = e;\n            }\n\n            if (config instanceof Error) {\n              error = config;\n              return;\n            }\n          } else {\n            config = require(resolvedConfigPath);\n          }\n\n          setConfigObject(config);\n        } catch (ex) {\n          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath));\n        }\n      }\n    });\n  } // set args from config object.\n  // it recursively checks nested objects.\n\n\n  function setConfigObject(config, prev) {\n    Object.keys(config).forEach(function (key) {\n      var value = config[key];\n      var fullKey = prev ? prev + '.' + key : key; // if the value is an inner object and we have dot-notation\n      // enabled, treat inner objects in config the same as\n      // heavily nested dot notations (foo.bar.apple).\n\n      if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n        // if the value is an object but not an array, check nested object\n        setConfigObject(value, fullKey);\n      } else {\n        // setting arguments via CLI takes precedence over\n        // values within the config file.\n        if (!hasKey(argv, fullKey.split('.')) || checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays']) {\n          setArg(fullKey, value);\n        }\n      }\n    });\n  } // set all config objects passed in opts\n\n\n  function setConfigObjects() {\n    if (typeof configObjects === 'undefined') return;\n    configObjects.forEach(function (configObject) {\n      setConfigObject(configObject);\n    });\n  }\n\n  function applyEnvVars(argv, configOnly) {\n    if (typeof envPrefix === 'undefined') return;\n    var prefix = typeof envPrefix === 'string' ? envPrefix : '';\n    Object.keys(process.env).forEach(function (envVar) {\n      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n        // get array of nested keys and convert them to camel case\n        var keys = envVar.split('__').map(function (key, i) {\n          if (i === 0) {\n            key = key.substring(prefix.length);\n          }\n\n          return camelCase(key);\n        });\n\n        if ((configOnly && flags.configs[keys.join('.')] || !configOnly) && !hasKey(argv, keys)) {\n          setArg(keys.join('.'), process.env[envVar]);\n        }\n      }\n    });\n  }\n\n  function applyCoercions(argv) {\n    var coerce;\n    var applied = {};\n    Object.keys(argv).forEach(function (key) {\n      if (!applied.hasOwnProperty(key)) {\n        // If we haven't already coerced this option via one of its aliases\n        coerce = checkAllAliases(key, flags.coercions);\n\n        if (typeof coerce === 'function') {\n          try {\n            var value = maybeCoerceNumber(key, coerce(argv[key]));\n            [].concat(flags.aliases[key] || [], key).forEach(ali => {\n              applied[ali] = argv[ali] = value;\n            });\n          } catch (err) {\n            error = err;\n          }\n        }\n      }\n    });\n  }\n\n  function setPlaceholderKeys(argv) {\n    flags.keys.forEach(key => {\n      // don't set placeholder keys for dot notation options 'foo.bar'.\n      if (~key.indexOf('.')) return;\n      if (typeof argv[key] === 'undefined') argv[key] = undefined;\n    });\n    return argv;\n  }\n\n  function applyDefaultsAndAliases(obj, aliases, defaults) {\n    Object.keys(defaults).forEach(function (key) {\n      if (!hasKey(obj, key.split('.'))) {\n        setKey(obj, key.split('.'), defaults[key]);\n        (aliases[key] || []).forEach(function (x) {\n          if (hasKey(obj, x.split('.'))) return;\n          setKey(obj, x.split('.'), defaults[key]);\n        });\n      }\n    });\n  }\n\n  function hasKey(obj, keys) {\n    var o = obj;\n    if (!configuration['dot-notation']) keys = [keys.join('.')];\n    keys.slice(0, -1).forEach(function (key) {\n      o = o[key] || {};\n    });\n    var key = keys[keys.length - 1];\n    if (typeof o !== 'object') return false;else return key in o;\n  }\n\n  function setKey(obj, keys, value) {\n    var o = obj;\n    if (!configuration['dot-notation']) keys = [keys.join('.')];\n    keys.slice(0, -1).forEach(function (key, index) {\n      // TODO(bcoe): in the next major version of yargs, switch to\n      // Object.create(null) for dot notation:\n      key = sanitizeKey(key);\n\n      if (typeof o === 'object' && o[key] === undefined) {\n        o[key] = {};\n      }\n\n      if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n        // ensure that o[key] is an array, and that the last item is an empty object.\n        if (Array.isArray(o[key])) {\n          o[key].push({});\n        } else {\n          o[key] = [o[key], {}];\n        } // we want to update the empty object at the end of the o[key] array, so set o to that object\n\n\n        o = o[key][o[key].length - 1];\n      } else {\n        o = o[key];\n      }\n    }); // TODO(bcoe): in the next major version of yargs, switch to\n    // Object.create(null) for dot notation:\n\n    const key = sanitizeKey(keys[keys.length - 1]);\n    const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);\n    const isValueArray = Array.isArray(value);\n    let duplicate = configuration['duplicate-arguments-array']; // nargs has higher priority than duplicate\n\n    if (!duplicate && checkAllAliases(key, flags.nargs)) {\n      duplicate = true;\n\n      if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {\n        o[key] = undefined;\n      }\n    }\n\n    if (value === increment) {\n      o[key] = increment(o[key]);\n    } else if (Array.isArray(o[key])) {\n      if (duplicate && isTypeArray && isValueArray) {\n        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);\n      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n        o[key] = value;\n      } else {\n        o[key] = o[key].concat([value]);\n      }\n    } else if (o[key] === undefined && isTypeArray) {\n      o[key] = isValueArray ? value : [value];\n    } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts))) {\n      o[key] = [o[key], value];\n    } else {\n      o[key] = value;\n    }\n  } // extend the aliases list with inferred aliases.\n\n\n  function extendAliases() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    args.forEach(function (obj) {\n      Object.keys(obj || {}).forEach(function (key) {\n        // short-circuit if we've already added a key\n        // to the aliases array, for example it might\n        // exist in both 'opts.default' and 'opts.key'.\n        if (flags.aliases[key]) return;\n        flags.aliases[key] = [].concat(aliases[key] || []); // For \"--option-name\", also set argv.optionName\n\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (/-/.test(x) && configuration['camel-case-expansion']) {\n            var c = camelCase(x);\n\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c);\n              newAliases[c] = true;\n            }\n          }\n        }); // For \"--optionName\", also set argv['option-name']\n\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n            var c = decamelize(x, '-');\n\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c);\n              newAliases[c] = true;\n            }\n          }\n        });\n        flags.aliases[key].forEach(function (x) {\n          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n            return x !== y;\n          }));\n        });\n      });\n    });\n  } // check if a flag is set for any of a key's aliases.\n\n\n  function checkAllAliases(key, flag) {\n    var isSet = false;\n    var toCheck = [].concat(flags.aliases[key] || [], key);\n    toCheck.forEach(function (key) {\n      if (flag.hasOwnProperty(key)) isSet = flag[key];\n    });\n    return isSet;\n  }\n\n  function hasAnyFlag(key) {\n    // XXX Switch to [].concat(...Object.values(flags)) once node.js 6 is dropped\n    var toCheck = [].concat(...Object.keys(flags).map(k => flags[k]));\n    return toCheck.some(function (flag) {\n      return flag[key];\n    });\n  }\n\n  function hasFlagsMatching(arg) {\n    for (var _len2 = arguments.length, patterns = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      patterns[_key2 - 1] = arguments[_key2];\n    }\n\n    var toCheck = [].concat(...patterns);\n    return toCheck.some(function (pattern) {\n      var match = arg.match(pattern);\n      return match && hasAnyFlag(match[1]);\n    });\n  } // based on a simplified version of the short flag group parsing logic\n\n\n  function hasAllShortFlags(arg) {\n    // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group\n    if (arg.match(negative) || !arg.match(/^-[^-]+/)) {\n      return false;\n    }\n\n    var hasAllFlags = true;\n    var letters = arg.slice(1).split('');\n    var next;\n\n    for (var j = 0; j < letters.length; j++) {\n      next = arg.slice(j + 2);\n\n      if (!hasAnyFlag(letters[j])) {\n        hasAllFlags = false;\n        break;\n      }\n\n      if (letters[j + 1] && letters[j + 1] === '=' || next === '-' || /[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\\W/)) {\n        break;\n      }\n    }\n\n    return hasAllFlags;\n  }\n\n  function isUnknownOptionAsArg(arg) {\n    return configuration['unknown-options-as-args'] && isUnknownOption(arg);\n  }\n\n  function isUnknownOption(arg) {\n    arg = arg.replace(/^-{3,}/, '---'); // ignore negative numbers\n\n    if (arg.match(negative)) {\n      return false;\n    } // if this is a short option group and all of them are configured, it isn't unknown\n\n\n    if (hasAllShortFlags(arg)) {\n      return false;\n    } // e.g. '--count=2'\n\n\n    const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/; // e.g. '-a' or '--arg'\n\n    const normalFlag = /^-+([^=]+?)$/; // e.g. '-a-'\n\n    const flagEndingInHyphen = /^-+([^=]+?)-$/; // e.g. '-abc123'\n\n    const flagEndingInDigits = /^-+([^=]+?)\\d+$/; // e.g. '-a/usr/local'\n\n    const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/; // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method\n\n    return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);\n  } // make a best effor to pick a default value\n  // for an option based on name and type.\n\n\n  function defaultValue(key) {\n    if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {\n      return defaults[key];\n    } else {\n      return defaultForType(guessType(key));\n    }\n  } // return a default value, given the type of a flag.,\n  // e.g., key of type 'string' will default to '', rather than 'true'.\n\n\n  function defaultForType(type) {\n    var def = {\n      boolean: true,\n      string: '',\n      number: undefined,\n      array: []\n    };\n    return def[type];\n  } // given a flag, enforce a default type.\n\n\n  function guessType(key) {\n    var type = 'boolean';\n    if (checkAllAliases(key, flags.strings)) type = 'string';else if (checkAllAliases(key, flags.numbers)) type = 'number';else if (checkAllAliases(key, flags.bools)) type = 'boolean';else if (checkAllAliases(key, flags.arrays)) type = 'array';\n    return type;\n  }\n\n  function isNumber(x) {\n    if (x === null || x === undefined) return false; // if loaded from config, may already be a number.\n\n    if (typeof x === 'number') return true; // hexadecimal.\n\n    if (/^0x[0-9a-f]+$/i.test(x)) return true; // don't treat 0123 as a number; as it drops the leading '0'.\n\n    if (x.length > 1 && x[0] === '0') return false;\n    return /^[-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x);\n  }\n\n  function isUndefined(num) {\n    return num === undefined;\n  }\n\n  return {\n    argv: argv,\n    error: error,\n    aliases: flags.aliases,\n    newAliases: newAliases,\n    configuration: configuration\n  };\n} // if any aliases reference each other, we should\n// merge them together.\n\n\nfunction combineAliases(aliases) {\n  var aliasArrays = [];\n  var change = true;\n  var combined = {}; // turn alias lookup hash {key: ['alias1', 'alias2']} into\n  // a simple array ['key', 'alias1', 'alias2']\n\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push([].concat(aliases[key], key));\n  }); // combine arrays until zero changes are\n  // made in an iteration.\n\n  while (change) {\n    change = false;\n\n    for (var i = 0; i < aliasArrays.length; i++) {\n      for (var ii = i + 1; ii < aliasArrays.length; ii++) {\n        var intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1;\n        });\n\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);\n          aliasArrays.splice(ii, 1);\n          change = true;\n          break;\n        }\n      }\n    }\n  } // map arrays back to the hash-lookup (de-dupe while\n  // we're at it).\n\n\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i;\n    });\n    combined[aliasArray.pop()] = aliasArray;\n  });\n  return combined;\n} // this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\n\n\nfunction increment(orig) {\n  return orig !== undefined ? orig + 1 : 1;\n}\n\nfunction Parser(args, opts) {\n  var result = parse(args.slice(), opts);\n  return result.argv;\n} // parse arguments and return detailed\n// meta information, aliases, etc.\n\n\nParser.detailed = function (args, opts) {\n  return parse(args.slice(), opts);\n}; // TODO(bcoe): in the next major version of yargs, switch to\n// Object.create(null) for dot notation:\n\n\nfunction sanitizeKey(key) {\n  if (key === '__proto__') return '___proto___';\n  return key;\n}\n\nmodule.exports = Parser;","map":{"version":3,"names":["camelCase","require","decamelize","path","tokenizeArgString","util","parse","args","opts","aliases","combineAliases","alias","configuration","Object","assign","defaults","default","configObjects","envPrefix","notFlagsOption","notFlagsArgv","newAliases","__","format","error","flags","arrays","bools","strings","numbers","counts","normalize","configs","nargs","coercions","keys","negative","negatedBoolean","RegExp","concat","array","filter","Boolean","forEach","opt","key","assignment","map","boolean","string","number","pop","push","count","narg","k","coerce","Array","isArray","config","extendAliases","argv","_","notFlags","i","length","arg","broken","letters","m","next","value","isUnknownOptionAsArg","match","checkAllAliases","splice","eatNargs","eatArray","setArg","undefined","test","defaultValue","slice","split","j","maybeCoerceNumber","applyEnvVars","setConfig","setConfigObjects","applyDefaultsAndAliases","applyCoercions","setPlaceholderKeys","hasKey","includes","prop","join","ii","toEat","available","Error","consumed","Math","min","argsToSet","isUndefined","hasOwnProperty","processValue","val","addNewAlias","splitKey","setKey","x","a","shift","__defineSetter__","v","__defineGetter__","substring","increment","shouldCoerceNumber","isNumber","Number","isSafeInteger","floor","configLookup","configKey","configPath","resolvedConfigPath","resolve","process","cwd","e","setConfigObject","ex","prev","fullKey","configObject","configOnly","prefix","env","envVar","lastIndexOf","applied","ali","err","indexOf","obj","o","index","sanitizeKey","isTypeArray","isValueArray","duplicate","c","y","flag","isSet","toCheck","hasAnyFlag","some","hasFlagsMatching","patterns","pattern","hasAllShortFlags","hasAllFlags","isUnknownOption","replace","flagWithEquals","normalFlag","flagEndingInHyphen","flagEndingInDigits","flagEndingInNonWordCharacters","defaultForType","guessType","type","def","num","aliasArrays","change","combined","intersect","aliasArray","self","orig","Parser","result","detailed","module","exports"],"sources":["/home/lawrence/learn-react/react-notes-app/node_modules/yargs-parser/index.js"],"sourcesContent":["var camelCase = require('camelcase')\nvar decamelize = require('decamelize')\nvar path = require('path')\nvar tokenizeArgString = require('./lib/tokenize-arg-string')\nvar util = require('util')\n\nfunction parse (args, opts) {\n  if (!opts) opts = {}\n  // allow a string argument to be passed in rather\n  // than an argv array.\n  args = tokenizeArgString(args)\n\n  // aliases might have transitive relationships, normalize this.\n  var aliases = combineAliases(opts.alias || {})\n  var configuration = Object.assign({\n    'short-option-groups': true,\n    'camel-case-expansion': true,\n    'dot-notation': true,\n    'parse-numbers': true,\n    'boolean-negation': true,\n    'negation-prefix': 'no-',\n    'duplicate-arguments-array': true,\n    'flatten-duplicate-arrays': true,\n    'populate--': false,\n    'combine-arrays': false,\n    'set-placeholder-key': false,\n    'halt-at-non-option': false,\n    'strip-aliased': false,\n    'strip-dashed': false,\n    'unknown-options-as-args': false\n  }, opts.configuration)\n  var defaults = opts.default || {}\n  var configObjects = opts.configObjects || []\n  var envPrefix = opts.envPrefix\n  var notFlagsOption = configuration['populate--']\n  var notFlagsArgv = notFlagsOption ? '--' : '_'\n  var newAliases = {}\n  // allow a i18n handler to be passed in, default to a fake one (util.format).\n  var __ = opts.__ || util.format\n  var error = null\n  var flags = {\n    aliases: {},\n    arrays: {},\n    bools: {},\n    strings: {},\n    numbers: {},\n    counts: {},\n    normalize: {},\n    configs: {},\n    nargs: {},\n    coercions: {},\n    keys: []\n  }\n  var negative = /^-[0-9]+(\\.[0-9]+)?/\n  var negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)')\n\n  ;[].concat(opts.array).filter(Boolean).forEach(function (opt) {\n    var key = opt.key || opt\n\n    // assign to flags[bools|strings|numbers]\n    const assignment = Object.keys(opt).map(function (key) {\n      return ({\n        boolean: 'bools',\n        string: 'strings',\n        number: 'numbers'\n      })[key]\n    }).filter(Boolean).pop()\n\n    // assign key to be coerced\n    if (assignment) {\n      flags[assignment][key] = true\n    }\n\n    flags.arrays[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.boolean).filter(Boolean).forEach(function (key) {\n    flags.bools[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.string).filter(Boolean).forEach(function (key) {\n    flags.strings[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.number).filter(Boolean).forEach(function (key) {\n    flags.numbers[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.count).filter(Boolean).forEach(function (key) {\n    flags.counts[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {\n    flags.normalize[key] = true\n    flags.keys.push(key)\n  })\n\n  Object.keys(opts.narg || {}).forEach(function (k) {\n    flags.nargs[k] = opts.narg[k]\n    flags.keys.push(k)\n  })\n\n  Object.keys(opts.coerce || {}).forEach(function (k) {\n    flags.coercions[k] = opts.coerce[k]\n    flags.keys.push(k)\n  })\n\n  if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n    ;[].concat(opts.config).filter(Boolean).forEach(function (key) {\n      flags.configs[key] = true\n    })\n  } else {\n    Object.keys(opts.config || {}).forEach(function (k) {\n      flags.configs[k] = opts.config[k]\n    })\n  }\n\n  // create a lookup table that takes into account all\n  // combinations of aliases: {f: ['foo'], foo: ['f']}\n  extendAliases(opts.key, aliases, opts.default, flags.arrays)\n\n  // apply default values to all aliases.\n  Object.keys(defaults).forEach(function (key) {\n    (flags.aliases[key] || []).forEach(function (alias) {\n      defaults[alias] = defaults[key]\n    })\n  })\n\n  var argv = { _: [] }\n  var notFlags = []\n\n  for (var i = 0; i < args.length; i++) {\n    var arg = args[i]\n    var broken\n    var key\n    var letters\n    var m\n    var next\n    var value\n\n    if (isUnknownOptionAsArg(arg)) {\n      argv._.push(arg)\n    // -- separated by =\n    } else if (arg.match(/^--.+=/) || (\n      !configuration['short-option-groups'] && arg.match(/^-.+=/)\n    )) {\n      // Using [\\s\\S] instead of . because js doesn't support the\n      // 'dotall' regex modifier. See:\n      // http://stackoverflow.com/a/1068308/13216\n      m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/)\n\n      // nargs format = '--f=monkey washing cat'\n      if (checkAllAliases(m[1], flags.nargs)) {\n        args.splice(i + 1, 0, m[2])\n        i = eatNargs(i, m[1], args)\n      // arrays format = '--f=a b c'\n      } else if (checkAllAliases(m[1], flags.arrays)) {\n        args.splice(i + 1, 0, m[2])\n        i = eatArray(i, m[1], args)\n      } else {\n        setArg(m[1], m[2])\n      }\n    } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n      key = arg.match(negatedBoolean)[1]\n      setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false)\n\n    // -- separated by space.\n    } else if (arg.match(/^--.+/) || (\n      !configuration['short-option-groups'] && arg.match(/^-[^-]+/)\n    )) {\n      key = arg.match(/^--?(.+)/)[1]\n\n      // nargs format = '--foo a b c'\n      // should be truthy even if: flags.nargs[key] === 0\n      if (checkAllAliases(key, flags.nargs) !== false) {\n        i = eatNargs(i, key, args)\n      // array format = '--foo a b c'\n      } else if (checkAllAliases(key, flags.arrays)) {\n        i = eatArray(i, key, args)\n      } else {\n        next = args[i + 1]\n\n        if (next !== undefined && (!next.match(/^-/) ||\n          next.match(negative)) &&\n          !checkAllAliases(key, flags.bools) &&\n          !checkAllAliases(key, flags.counts)) {\n          setArg(key, next)\n          i++\n        } else if (/^(true|false)$/.test(next)) {\n          setArg(key, next)\n          i++\n        } else {\n          setArg(key, defaultValue(key))\n        }\n      }\n\n    // dot-notation flag separated by '='.\n    } else if (arg.match(/^-.\\..+=/)) {\n      m = arg.match(/^-([^=]+)=([\\s\\S]*)$/)\n      setArg(m[1], m[2])\n\n    // dot-notation flag separated by space.\n    } else if (arg.match(/^-.\\..+/)) {\n      next = args[i + 1]\n      key = arg.match(/^-(.\\..+)/)[1]\n\n      if (next !== undefined && !next.match(/^-/) &&\n        !checkAllAliases(key, flags.bools) &&\n        !checkAllAliases(key, flags.counts)) {\n        setArg(key, next)\n        i++\n      } else {\n        setArg(key, defaultValue(key))\n      }\n    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n      letters = arg.slice(1, -1).split('')\n      broken = false\n\n      for (var j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2)\n\n        if (letters[j + 1] && letters[j + 1] === '=') {\n          value = arg.slice(j + 3)\n          key = letters[j]\n\n          // nargs format = '-f=monkey washing cat'\n          if (checkAllAliases(key, flags.nargs)) {\n            args.splice(i + 1, 0, value)\n            i = eatNargs(i, key, args)\n          // array format = '-f=a b c'\n          } else if (checkAllAliases(key, flags.arrays)) {\n            args.splice(i + 1, 0, value)\n            i = eatArray(i, key, args)\n          } else {\n            setArg(key, value)\n          }\n\n          broken = true\n          break\n        }\n\n        if (next === '-') {\n          setArg(letters[j], next)\n          continue\n        }\n\n        // current letter is an alphabetic character and next value is a number\n        if (/[A-Za-z]/.test(letters[j]) &&\n          /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        }\n\n        if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        } else {\n          setArg(letters[j], defaultValue(letters[j]))\n        }\n      }\n\n      key = arg.slice(-1)[0]\n\n      if (!broken && key !== '-') {\n        // nargs format = '-f a b c'\n        // should be truthy even if: flags.nargs[key] === 0\n        if (checkAllAliases(key, flags.nargs) !== false) {\n          i = eatNargs(i, key, args)\n        // array format = '-f a b c'\n        } else if (checkAllAliases(key, flags.arrays)) {\n          i = eatArray(i, key, args)\n        } else {\n          next = args[i + 1]\n\n          if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||\n            next.match(negative)) &&\n            !checkAllAliases(key, flags.bools) &&\n            !checkAllAliases(key, flags.counts)) {\n            setArg(key, next)\n            i++\n          } else if (/^(true|false)$/.test(next)) {\n            setArg(key, next)\n            i++\n          } else {\n            setArg(key, defaultValue(key))\n          }\n        }\n      }\n    } else if (arg === '--') {\n      notFlags = args.slice(i + 1)\n      break\n    } else if (configuration['halt-at-non-option']) {\n      notFlags = args.slice(i)\n      break\n    } else {\n      argv._.push(maybeCoerceNumber('_', arg))\n    }\n  }\n\n  // order of precedence:\n  // 1. command line arg\n  // 2. value from env var\n  // 3. value from config file\n  // 4. value from config objects\n  // 5. configured default value\n  applyEnvVars(argv, true) // special case: check env vars that point to config file\n  applyEnvVars(argv, false)\n  setConfig(argv)\n  setConfigObjects()\n  applyDefaultsAndAliases(argv, flags.aliases, defaults)\n  applyCoercions(argv)\n  if (configuration['set-placeholder-key']) setPlaceholderKeys(argv)\n\n  // for any counts either not in args or without an explicit default, set to 0\n  Object.keys(flags.counts).forEach(function (key) {\n    if (!hasKey(argv, key.split('.'))) setArg(key, 0)\n  })\n\n  // '--' defaults to undefined.\n  if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = []\n  notFlags.forEach(function (key) {\n    argv[notFlagsArgv].push(key)\n  })\n\n  if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n    Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\n      delete argv[key]\n    })\n  }\n\n  if (configuration['strip-aliased']) {\n    // XXX Switch to [].concat(...Object.values(aliases)) once node.js 6 is dropped\n    ;[].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\n      if (configuration['camel-case-expansion']) {\n        delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')]\n      }\n\n      delete argv[alias]\n    })\n  }\n\n  // how many arguments should we consume, based\n  // on the nargs option?\n  function eatNargs (i, key, args) {\n    var ii\n    const toEat = checkAllAliases(key, flags.nargs)\n\n    if (toEat === 0) {\n      setArg(key, defaultValue(key))\n      return i\n    }\n\n    // nargs will not consume flag arguments, e.g., -abc, --foo,\n    // and terminates when one is observed.\n    var available = 0\n    for (ii = i + 1; ii < args.length; ii++) {\n      if (!args[ii].match(/^-[^0-9]/) || isUnknownOptionAsArg(args[ii])) available++\n      else break\n    }\n\n    if (available < toEat) error = Error(__('Not enough arguments following: %s', key))\n\n    const consumed = Math.min(available, toEat)\n    for (ii = i + 1; ii < (consumed + i + 1); ii++) {\n      setArg(key, args[ii])\n    }\n\n    return (i + consumed)\n  }\n\n  // if an option is an array, eat all non-hyphenated arguments\n  // following it... YUM!\n  // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n  function eatArray (i, key, args) {\n    let argsToSet = []\n    let next = args[i + 1]\n\n    if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {\n      argsToSet.push(true)\n    } else if (isUndefined(next) || (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {\n      // for keys without value ==> argsToSet remains an empty []\n      // set user default value, if available\n      if (defaults.hasOwnProperty(key)) {\n        argsToSet.push(defaults[key])\n      }\n    } else {\n      for (var ii = i + 1; ii < args.length; ii++) {\n        next = args[ii]\n        if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break\n        i = ii\n        argsToSet.push(processValue(key, next))\n      }\n    }\n\n    setArg(key, argsToSet)\n    return i\n  }\n\n  function setArg (key, val) {\n    if (/-/.test(key) && configuration['camel-case-expansion']) {\n      var alias = key.split('.').map(function (prop) {\n        return camelCase(prop)\n      }).join('.')\n      addNewAlias(key, alias)\n    }\n\n    var value = processValue(key, val)\n\n    var splitKey = key.split('.')\n    setKey(argv, splitKey, value)\n\n    // handle populating aliases of the full key\n    if (flags.aliases[key] && flags.aliases[key].forEach) {\n      flags.aliases[key].forEach(function (x) {\n        x = x.split('.')\n        setKey(argv, x, value)\n      })\n    }\n\n    // handle populating aliases of the first element of the dot-notation key\n    if (splitKey.length > 1 && configuration['dot-notation']) {\n      ;(flags.aliases[splitKey[0]] || []).forEach(function (x) {\n        x = x.split('.')\n\n        // expand alias with nested objects in key\n        var a = [].concat(splitKey)\n        a.shift() // nuke the old key.\n        x = x.concat(a)\n\n        setKey(argv, x, value)\n      })\n    }\n\n    // Set normalize getter and setter when key is in 'normalize' but isn't an array\n    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n      var keys = [key].concat(flags.aliases[key] || [])\n      keys.forEach(function (key) {\n        argv.__defineSetter__(key, function (v) {\n          val = path.normalize(v)\n        })\n\n        argv.__defineGetter__(key, function () {\n          return typeof val === 'string' ? path.normalize(val) : val\n        })\n      })\n    }\n  }\n\n  function addNewAlias (key, alias) {\n    if (!(flags.aliases[key] && flags.aliases[key].length)) {\n      flags.aliases[key] = [alias]\n      newAliases[alias] = true\n    }\n    if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n      addNewAlias(alias, key)\n    }\n  }\n\n  function processValue (key, val) {\n    // strings may be quoted, clean this up as we assign values.\n    if (typeof val === 'string' &&\n      (val[0] === \"'\" || val[0] === '\"') &&\n      val[val.length - 1] === val[0]\n    ) {\n      val = val.substring(1, val.length - 1)\n    }\n\n    // handle parsing boolean arguments --foo=true --bar false.\n    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n      if (typeof val === 'string') val = val === 'true'\n    }\n\n    var value = Array.isArray(val)\n      ? val.map(function (v) { return maybeCoerceNumber(key, v) })\n      : maybeCoerceNumber(key, val)\n\n    // increment a count given as arg (either no value or value parsed as boolean)\n    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n      value = increment\n    }\n\n    // Set normalized value when key is in 'normalize' and in 'arrays'\n    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n      if (Array.isArray(val)) value = val.map(path.normalize)\n      else value = path.normalize(val)\n    }\n    return value\n  }\n\n  function maybeCoerceNumber (key, value) {\n    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n      const shouldCoerceNumber = isNumber(value) && configuration['parse-numbers'] && (\n        Number.isSafeInteger(Math.floor(value))\n      )\n      if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) value = Number(value)\n    }\n    return value\n  }\n\n  // set args from config.json file, this should be\n  // applied last so that defaults can be applied.\n  function setConfig (argv) {\n    var configLookup = {}\n\n    // expand defaults/aliases, in-case any happen to reference\n    // the config.json file.\n    applyDefaultsAndAliases(configLookup, flags.aliases, defaults)\n\n    Object.keys(flags.configs).forEach(function (configKey) {\n      var configPath = argv[configKey] || configLookup[configKey]\n      if (configPath) {\n        try {\n          var config = null\n          var resolvedConfigPath = path.resolve(process.cwd(), configPath)\n\n          if (typeof flags.configs[configKey] === 'function') {\n            try {\n              config = flags.configs[configKey](resolvedConfigPath)\n            } catch (e) {\n              config = e\n            }\n            if (config instanceof Error) {\n              error = config\n              return\n            }\n          } else {\n            config = require(resolvedConfigPath)\n          }\n\n          setConfigObject(config)\n        } catch (ex) {\n          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))\n        }\n      }\n    })\n  }\n\n  // set args from config object.\n  // it recursively checks nested objects.\n  function setConfigObject (config, prev) {\n    Object.keys(config).forEach(function (key) {\n      var value = config[key]\n      var fullKey = prev ? prev + '.' + key : key\n\n      // if the value is an inner object and we have dot-notation\n      // enabled, treat inner objects in config the same as\n      // heavily nested dot notations (foo.bar.apple).\n      if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n        // if the value is an object but not an array, check nested object\n        setConfigObject(value, fullKey)\n      } else {\n        // setting arguments via CLI takes precedence over\n        // values within the config file.\n        if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {\n          setArg(fullKey, value)\n        }\n      }\n    })\n  }\n\n  // set all config objects passed in opts\n  function setConfigObjects () {\n    if (typeof configObjects === 'undefined') return\n    configObjects.forEach(function (configObject) {\n      setConfigObject(configObject)\n    })\n  }\n\n  function applyEnvVars (argv, configOnly) {\n    if (typeof envPrefix === 'undefined') return\n\n    var prefix = typeof envPrefix === 'string' ? envPrefix : ''\n    Object.keys(process.env).forEach(function (envVar) {\n      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n        // get array of nested keys and convert them to camel case\n        var keys = envVar.split('__').map(function (key, i) {\n          if (i === 0) {\n            key = key.substring(prefix.length)\n          }\n          return camelCase(key)\n        })\n\n        if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {\n          setArg(keys.join('.'), process.env[envVar])\n        }\n      }\n    })\n  }\n\n  function applyCoercions (argv) {\n    var coerce\n    var applied = {}\n    Object.keys(argv).forEach(function (key) {\n      if (!applied.hasOwnProperty(key)) { // If we haven't already coerced this option via one of its aliases\n        coerce = checkAllAliases(key, flags.coercions)\n        if (typeof coerce === 'function') {\n          try {\n            var value = maybeCoerceNumber(key, coerce(argv[key]))\n            ;([].concat(flags.aliases[key] || [], key)).forEach(ali => {\n              applied[ali] = argv[ali] = value\n            })\n          } catch (err) {\n            error = err\n          }\n        }\n      }\n    })\n  }\n\n  function setPlaceholderKeys (argv) {\n    flags.keys.forEach((key) => {\n      // don't set placeholder keys for dot notation options 'foo.bar'.\n      if (~key.indexOf('.')) return\n      if (typeof argv[key] === 'undefined') argv[key] = undefined\n    })\n    return argv\n  }\n\n  function applyDefaultsAndAliases (obj, aliases, defaults) {\n    Object.keys(defaults).forEach(function (key) {\n      if (!hasKey(obj, key.split('.'))) {\n        setKey(obj, key.split('.'), defaults[key])\n\n        ;(aliases[key] || []).forEach(function (x) {\n          if (hasKey(obj, x.split('.'))) return\n          setKey(obj, x.split('.'), defaults[key])\n        })\n      }\n    })\n  }\n\n  function hasKey (obj, keys) {\n    var o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key) {\n      o = (o[key] || {})\n    })\n\n    var key = keys[keys.length - 1]\n\n    if (typeof o !== 'object') return false\n    else return key in o\n  }\n\n  function setKey (obj, keys, value) {\n    var o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key, index) {\n      // TODO(bcoe): in the next major version of yargs, switch to\n      // Object.create(null) for dot notation:\n      key = sanitizeKey(key)\n\n      if (typeof o === 'object' && o[key] === undefined) {\n        o[key] = {}\n      }\n\n      if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n        // ensure that o[key] is an array, and that the last item is an empty object.\n        if (Array.isArray(o[key])) {\n          o[key].push({})\n        } else {\n          o[key] = [o[key], {}]\n        }\n\n        // we want to update the empty object at the end of the o[key] array, so set o to that object\n        o = o[key][o[key].length - 1]\n      } else {\n        o = o[key]\n      }\n    })\n\n    // TODO(bcoe): in the next major version of yargs, switch to\n    // Object.create(null) for dot notation:\n    const key = sanitizeKey(keys[keys.length - 1])\n\n    const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays)\n    const isValueArray = Array.isArray(value)\n    let duplicate = configuration['duplicate-arguments-array']\n\n    // nargs has higher priority than duplicate\n    if (!duplicate && checkAllAliases(key, flags.nargs)) {\n      duplicate = true\n      if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {\n        o[key] = undefined\n      }\n    }\n\n    if (value === increment) {\n      o[key] = increment(o[key])\n    } else if (Array.isArray(o[key])) {\n      if (duplicate && isTypeArray && isValueArray) {\n        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value])\n      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n        o[key] = value\n      } else {\n        o[key] = o[key].concat([value])\n      }\n    } else if (o[key] === undefined && isTypeArray) {\n      o[key] = isValueArray ? value : [value]\n    } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts))) {\n      o[key] = [ o[key], value ]\n    } else {\n      o[key] = value\n    }\n  }\n\n  // extend the aliases list with inferred aliases.\n  function extendAliases (...args) {\n    args.forEach(function (obj) {\n      Object.keys(obj || {}).forEach(function (key) {\n        // short-circuit if we've already added a key\n        // to the aliases array, for example it might\n        // exist in both 'opts.default' and 'opts.key'.\n        if (flags.aliases[key]) return\n\n        flags.aliases[key] = [].concat(aliases[key] || [])\n        // For \"--option-name\", also set argv.optionName\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (/-/.test(x) && configuration['camel-case-expansion']) {\n            var c = camelCase(x)\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c)\n              newAliases[c] = true\n            }\n          }\n        })\n        // For \"--optionName\", also set argv['option-name']\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n            var c = decamelize(x, '-')\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c)\n              newAliases[c] = true\n            }\n          }\n        })\n        flags.aliases[key].forEach(function (x) {\n          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n            return x !== y\n          }))\n        })\n      })\n    })\n  }\n\n  // check if a flag is set for any of a key's aliases.\n  function checkAllAliases (key, flag) {\n    var isSet = false\n    var toCheck = [].concat(flags.aliases[key] || [], key)\n\n    toCheck.forEach(function (key) {\n      if (flag.hasOwnProperty(key)) isSet = flag[key]\n    })\n\n    return isSet\n  }\n\n  function hasAnyFlag (key) {\n    // XXX Switch to [].concat(...Object.values(flags)) once node.js 6 is dropped\n    var toCheck = [].concat(...Object.keys(flags).map(k => flags[k]))\n\n    return toCheck.some(function (flag) {\n      return flag[key]\n    })\n  }\n\n  function hasFlagsMatching (arg, ...patterns) {\n    var toCheck = [].concat(...patterns)\n    return toCheck.some(function (pattern) {\n      var match = arg.match(pattern)\n      return match && hasAnyFlag(match[1])\n    })\n  }\n\n  // based on a simplified version of the short flag group parsing logic\n  function hasAllShortFlags (arg) {\n    // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group\n    if (arg.match(negative) || !arg.match(/^-[^-]+/)) { return false }\n    var hasAllFlags = true\n    var letters = arg.slice(1).split('')\n    var next\n    for (var j = 0; j < letters.length; j++) {\n      next = arg.slice(j + 2)\n\n      if (!hasAnyFlag(letters[j])) {\n        hasAllFlags = false\n        break\n      }\n\n      if ((letters[j + 1] && letters[j + 1] === '=') ||\n        next === '-' ||\n        (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) ||\n        (letters[j + 1] && letters[j + 1].match(/\\W/))) {\n        break\n      }\n    }\n    return hasAllFlags\n  }\n\n  function isUnknownOptionAsArg (arg) {\n    return configuration['unknown-options-as-args'] && isUnknownOption(arg)\n  }\n\n  function isUnknownOption (arg) {\n    arg = arg.replace(/^-{3,}/, '---')\n    // ignore negative numbers\n    if (arg.match(negative)) { return false }\n    // if this is a short option group and all of them are configured, it isn't unknown\n    if (hasAllShortFlags(arg)) { return false }\n    // e.g. '--count=2'\n    const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/\n    // e.g. '-a' or '--arg'\n    const normalFlag = /^-+([^=]+?)$/\n    // e.g. '-a-'\n    const flagEndingInHyphen = /^-+([^=]+?)-$/\n    // e.g. '-abc123'\n    const flagEndingInDigits = /^-+([^=]+?)\\d+$/\n    // e.g. '-a/usr/local'\n    const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/\n    // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method\n    return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters)\n  }\n\n  // make a best effor to pick a default value\n  // for an option based on name and type.\n  function defaultValue (key) {\n    if (!checkAllAliases(key, flags.bools) &&\n        !checkAllAliases(key, flags.counts) &&\n        `${key}` in defaults) {\n      return defaults[key]\n    } else {\n      return defaultForType(guessType(key))\n    }\n  }\n\n  // return a default value, given the type of a flag.,\n  // e.g., key of type 'string' will default to '', rather than 'true'.\n  function defaultForType (type) {\n    var def = {\n      boolean: true,\n      string: '',\n      number: undefined,\n      array: []\n    }\n\n    return def[type]\n  }\n\n  // given a flag, enforce a default type.\n  function guessType (key) {\n    var type = 'boolean'\n\n    if (checkAllAliases(key, flags.strings)) type = 'string'\n    else if (checkAllAliases(key, flags.numbers)) type = 'number'\n    else if (checkAllAliases(key, flags.bools)) type = 'boolean'\n    else if (checkAllAliases(key, flags.arrays)) type = 'array'\n\n    return type\n  }\n\n  function isNumber (x) {\n    if (x === null || x === undefined) return false\n    // if loaded from config, may already be a number.\n    if (typeof x === 'number') return true\n    // hexadecimal.\n    if (/^0x[0-9a-f]+$/i.test(x)) return true\n    // don't treat 0123 as a number; as it drops the leading '0'.\n    if (x.length > 1 && x[0] === '0') return false\n    return /^[-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x)\n  }\n\n  function isUndefined (num) {\n    return num === undefined\n  }\n\n  return {\n    argv: argv,\n    error: error,\n    aliases: flags.aliases,\n    newAliases: newAliases,\n    configuration: configuration\n  }\n}\n\n// if any aliases reference each other, we should\n// merge them together.\nfunction combineAliases (aliases) {\n  var aliasArrays = []\n  var change = true\n  var combined = {}\n\n  // turn alias lookup hash {key: ['alias1', 'alias2']} into\n  // a simple array ['key', 'alias1', 'alias2']\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push(\n      [].concat(aliases[key], key)\n    )\n  })\n\n  // combine arrays until zero changes are\n  // made in an iteration.\n  while (change) {\n    change = false\n    for (var i = 0; i < aliasArrays.length; i++) {\n      for (var ii = i + 1; ii < aliasArrays.length; ii++) {\n        var intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1\n        })\n\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii])\n          aliasArrays.splice(ii, 1)\n          change = true\n          break\n        }\n      }\n    }\n  }\n\n  // map arrays back to the hash-lookup (de-dupe while\n  // we're at it).\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i\n    })\n    combined[aliasArray.pop()] = aliasArray\n  })\n\n  return combined\n}\n\n// this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\nfunction increment (orig) {\n  return orig !== undefined ? orig + 1 : 1\n}\n\nfunction Parser (args, opts) {\n  var result = parse(args.slice(), opts)\n\n  return result.argv\n}\n\n// parse arguments and return detailed\n// meta information, aliases, etc.\nParser.detailed = function (args, opts) {\n  return parse(args.slice(), opts)\n}\n\n// TODO(bcoe): in the next major version of yargs, switch to\n// Object.create(null) for dot notation:\nfunction sanitizeKey (key) {\n  if (key === '__proto__') return '___proto___'\n  return key\n}\n\nmodule.exports = Parser\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}