{"ast":null,"code":"'use strict';\n\nconst argsert = require('./argsert');\n\nconst objFilter = require('./obj-filter');\n\nconst specialKeys = ['$0', '--', '_']; // validation-type-stuff, missing params,\n// bad implications, custom checks.\n\nmodule.exports = function validation(yargs, usage, y18n) {\n  const __ = y18n.__;\n  const __n = y18n.__n;\n  const self = {}; // validate appropriate # of non-option\n  // arguments were provided, i.e., '_'.\n\n  self.nonOptionCount = function nonOptionCount(argv) {\n    const demandedCommands = yargs.getDemandedCommands(); // don't count currently executing commands\n\n    const _s = argv._.length - yargs.getContext().commands.length;\n\n    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n      if (_s < demandedCommands._.min) {\n        if (demandedCommands._.minMsg !== undefined) {\n          usage.fail( // replace $0 with observed, $1 with expected.\n          demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\\$0/g, _s).replace(/\\$1/, demandedCommands._.min) : null);\n        } else {\n          usage.fail(__('Not enough non-option arguments: got %s, need at least %s', _s, demandedCommands._.min));\n        }\n      } else if (_s > demandedCommands._.max) {\n        if (demandedCommands._.maxMsg !== undefined) {\n          usage.fail( // replace $0 with observed, $1 with expected.\n          demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\\$0/g, _s).replace(/\\$1/, demandedCommands._.max) : null);\n        } else {\n          usage.fail(__('Too many non-option arguments: got %s, maximum of %s', _s, demandedCommands._.max));\n        }\n      }\n    }\n  }; // validate the appropriate # of <required>\n  // positional arguments were provided:\n\n\n  self.positionalCount = function positionalCount(required, observed) {\n    if (observed < required) {\n      usage.fail(__('Not enough non-option arguments: got %s, need at least %s', observed, required));\n    }\n  }; // make sure all the required arguments are present.\n\n\n  self.requiredArguments = function requiredArguments(argv) {\n    const demandedOptions = yargs.getDemandedOptions();\n    let missing = null;\n    Object.keys(demandedOptions).forEach(key => {\n      if (!argv.hasOwnProperty(key) || typeof argv[key] === 'undefined') {\n        missing = missing || {};\n        missing[key] = demandedOptions[key];\n      }\n    });\n\n    if (missing) {\n      const customMsgs = [];\n      Object.keys(missing).forEach(key => {\n        const msg = missing[key];\n\n        if (msg && customMsgs.indexOf(msg) < 0) {\n          customMsgs.push(msg);\n        }\n      });\n      const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n      usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n    }\n  }; // check for unknown arguments (strict-mode).\n\n\n  self.unknownArguments = function unknownArguments(argv, aliases, positionalMap) {\n    const commandKeys = yargs.getCommandInstance().getCommands();\n    const unknown = [];\n    const currentContext = yargs.getContext();\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && !positionalMap.hasOwnProperty(key) && !yargs._getParseContext().hasOwnProperty(key) && !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n        unknown.push(key);\n      }\n    });\n\n    if (currentContext.commands.length > 0 || commandKeys.length > 0) {\n      argv._.slice(currentContext.commands.length).forEach(key => {\n        if (commandKeys.indexOf(key) === -1) {\n          unknown.push(key);\n        }\n      });\n    }\n\n    if (unknown.length > 0) {\n      usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n    }\n  }; // check for a key that is not an alias, or for which every alias is new,\n  // implying that it was invented by the parser, e.g., during camelization\n\n\n  self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n    if (!aliases.hasOwnProperty(key)) {\n      return false;\n    }\n\n    const newAliases = yargs.parsed.newAliases;\n\n    for (let a of [key, ...aliases[key]]) {\n      if (!newAliases.hasOwnProperty(a) || !newAliases[key]) {\n        return true;\n      }\n    }\n\n    return false;\n  }; // validate arguments limited to enumerated choices\n\n\n  self.limitedChoices = function limitedChoices(argv) {\n    const options = yargs.getOptions();\n    const invalid = {};\n    if (!Object.keys(options.choices).length) return;\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && options.choices.hasOwnProperty(key)) {\n        [].concat(argv[key]).forEach(value => {\n          // TODO case-insensitive configurability\n          if (options.choices[key].indexOf(value) === -1 && value !== undefined) {\n            invalid[key] = (invalid[key] || []).concat(value);\n          }\n        });\n      }\n    });\n    const invalidKeys = Object.keys(invalid);\n    if (!invalidKeys.length) return;\n\n    let msg = __('Invalid values:');\n\n    invalidKeys.forEach(key => {\n      msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n    });\n    usage.fail(msg);\n  }; // custom checks, added using the `check` option on yargs.\n\n\n  let checks = [];\n\n  self.check = function check(f, global) {\n    checks.push({\n      func: f,\n      global\n    });\n  };\n\n  self.customChecks = function customChecks(argv, aliases) {\n    for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n      const func = f.func;\n      let result = null;\n\n      try {\n        result = func(argv, aliases);\n      } catch (err) {\n        usage.fail(err.message ? err.message : err, err);\n        continue;\n      }\n\n      if (!result) {\n        usage.fail(__('Argument check failed: %s', func.toString()));\n      } else if (typeof result === 'string' || result instanceof Error) {\n        usage.fail(result.toString(), result);\n      }\n    }\n  }; // check implications, argument foo implies => argument bar.\n\n\n  let implied = {};\n\n  self.implies = function implies(key, value) {\n    argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.implies(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n\n      if (!implied[key]) {\n        implied[key] = [];\n      }\n\n      if (Array.isArray(value)) {\n        value.forEach(i => self.implies(key, i));\n      } else {\n        implied[key].push(value);\n      }\n    }\n  };\n\n  self.getImplied = function getImplied() {\n    return implied;\n  };\n\n  function keyExists(argv, val) {\n    // convert string '1' to number 1\n    let num = Number(val);\n    val = isNaN(num) ? val : num;\n\n    if (typeof val === 'number') {\n      // check length of argv._\n      val = argv._.length >= val;\n    } else if (val.match(/^--no-.+/)) {\n      // check if key/value doesn't exist\n      val = val.match(/^--no-(.+)/)[1];\n      val = !argv[val];\n    } else {\n      // check if key/value exists\n      val = argv[val];\n    }\n\n    return val;\n  }\n\n  self.implications = function implications(argv) {\n    const implyFail = [];\n    Object.keys(implied).forEach(key => {\n      const origKey = key;\n      (implied[key] || []).forEach(value => {\n        let key = origKey;\n        const origValue = value;\n        key = keyExists(argv, key);\n        value = keyExists(argv, value);\n\n        if (key && !value) {\n          implyFail.push(` ${origKey} -> ${origValue}`);\n        }\n      });\n    });\n\n    if (implyFail.length) {\n      let msg = `${__('Implications failed:')}\\n`;\n      implyFail.forEach(value => {\n        msg += value;\n      });\n      usage.fail(msg);\n    }\n  };\n\n  let conflicting = {};\n\n  self.conflicts = function conflicts(key, value) {\n    argsert('<string|object> [array|string]', [key, value], arguments.length);\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.conflicts(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n\n      if (!conflicting[key]) {\n        conflicting[key] = [];\n      }\n\n      if (Array.isArray(value)) {\n        value.forEach(i => self.conflicts(key, i));\n      } else {\n        conflicting[key].push(value);\n      }\n    }\n  };\n\n  self.getConflicting = () => conflicting;\n\n  self.conflicting = function conflictingFn(argv) {\n    Object.keys(argv).forEach(key => {\n      if (conflicting[key]) {\n        conflicting[key].forEach(value => {\n          // we default keys to 'undefined' that have been configured, we should not\n          // apply conflicting check unless they are a value other than 'undefined'.\n          if (value && argv[key] !== undefined && argv[value] !== undefined) {\n            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n          }\n        });\n      }\n    });\n  };\n\n  self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n    const distance = require('./levenshtein');\n\n    const threshold = 3; // if it takes more than three edits, let's move on.\n\n    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n    let recommended = null;\n    let bestDistance = Infinity;\n\n    for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n      const d = distance(cmd, candidate);\n\n      if (d <= threshold && d < bestDistance) {\n        bestDistance = d;\n        recommended = candidate;\n      }\n    }\n\n    if (recommended) usage.fail(__('Did you mean %s?', recommended));\n  };\n\n  self.reset = function reset(localLookup) {\n    implied = objFilter(implied, (k, v) => !localLookup[k]);\n    conflicting = objFilter(conflicting, (k, v) => !localLookup[k]);\n    checks = checks.filter(c => c.global);\n    return self;\n  };\n\n  let frozens = [];\n\n  self.freeze = function freeze() {\n    let frozen = {};\n    frozens.push(frozen);\n    frozen.implied = implied;\n    frozen.checks = checks;\n    frozen.conflicting = conflicting;\n  };\n\n  self.unfreeze = function unfreeze() {\n    let frozen = frozens.pop();\n    implied = frozen.implied;\n    checks = frozen.checks;\n    conflicting = frozen.conflicting;\n  };\n\n  return self;\n};","map":{"version":3,"names":["argsert","require","objFilter","specialKeys","module","exports","validation","yargs","usage","y18n","__","__n","self","nonOptionCount","argv","demandedCommands","getDemandedCommands","_s","_","length","getContext","commands","min","max","minMsg","undefined","fail","replace","maxMsg","positionalCount","required","observed","requiredArguments","demandedOptions","getDemandedOptions","missing","Object","keys","forEach","key","hasOwnProperty","customMsgs","msg","indexOf","push","customMsg","join","unknownArguments","aliases","positionalMap","commandKeys","getCommandInstance","getCommands","unknown","currentContext","_getParseContext","isValidAndSomeAliasIsNotNew","slice","newAliases","parsed","a","limitedChoices","options","getOptions","invalid","choices","concat","value","invalidKeys","stringifiedValues","checks","check","f","global","func","customChecks","i","result","err","message","toString","Error","implied","implies","arguments","k","Array","isArray","getImplied","keyExists","val","num","Number","isNaN","match","implications","implyFail","origKey","origValue","conflicting","conflicts","getConflicting","conflictingFn","recommendCommands","cmd","potentialCommands","distance","threshold","sort","b","recommended","bestDistance","Infinity","candidate","d","reset","localLookup","v","filter","c","frozens","freeze","frozen","unfreeze","pop"],"sources":["/home/lawrence/learn-react/react-notes-app/node_modules/yargs/lib/validation.js"],"sourcesContent":["'use strict'\nconst argsert = require('./argsert')\nconst objFilter = require('./obj-filter')\nconst specialKeys = ['$0', '--', '_']\n\n// validation-type-stuff, missing params,\n// bad implications, custom checks.\nmodule.exports = function validation (yargs, usage, y18n) {\n  const __ = y18n.__\n  const __n = y18n.__n\n  const self = {}\n\n  // validate appropriate # of non-option\n  // arguments were provided, i.e., '_'.\n  self.nonOptionCount = function nonOptionCount (argv) {\n    const demandedCommands = yargs.getDemandedCommands()\n    // don't count currently executing commands\n    const _s = argv._.length - yargs.getContext().commands.length\n\n    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n      if (_s < demandedCommands._.min) {\n        if (demandedCommands._.minMsg !== undefined) {\n          usage.fail(\n            // replace $0 with observed, $1 with expected.\n            demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\\$0/g, _s).replace(/\\$1/, demandedCommands._.min) : null\n          )\n        } else {\n          usage.fail(\n            __('Not enough non-option arguments: got %s, need at least %s', _s, demandedCommands._.min)\n          )\n        }\n      } else if (_s > demandedCommands._.max) {\n        if (demandedCommands._.maxMsg !== undefined) {\n          usage.fail(\n            // replace $0 with observed, $1 with expected.\n            demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\\$0/g, _s).replace(/\\$1/, demandedCommands._.max) : null\n          )\n        } else {\n          usage.fail(\n            __('Too many non-option arguments: got %s, maximum of %s', _s, demandedCommands._.max)\n          )\n        }\n      }\n    }\n  }\n\n  // validate the appropriate # of <required>\n  // positional arguments were provided:\n  self.positionalCount = function positionalCount (required, observed) {\n    if (observed < required) {\n      usage.fail(\n        __('Not enough non-option arguments: got %s, need at least %s', observed, required)\n      )\n    }\n  }\n\n  // make sure all the required arguments are present.\n  self.requiredArguments = function requiredArguments (argv) {\n    const demandedOptions = yargs.getDemandedOptions()\n    let missing = null\n\n    Object.keys(demandedOptions).forEach((key) => {\n      if (!argv.hasOwnProperty(key) || typeof argv[key] === 'undefined') {\n        missing = missing || {}\n        missing[key] = demandedOptions[key]\n      }\n    })\n\n    if (missing) {\n      const customMsgs = []\n      Object.keys(missing).forEach((key) => {\n        const msg = missing[key]\n        if (msg && customMsgs.indexOf(msg) < 0) {\n          customMsgs.push(msg)\n        }\n      })\n\n      const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : ''\n\n      usage.fail(__n(\n        'Missing required argument: %s',\n        'Missing required arguments: %s',\n        Object.keys(missing).length,\n        Object.keys(missing).join(', ') + customMsg\n      ))\n    }\n  }\n\n  // check for unknown arguments (strict-mode).\n  self.unknownArguments = function unknownArguments (argv, aliases, positionalMap) {\n    const commandKeys = yargs.getCommandInstance().getCommands()\n    const unknown = []\n    const currentContext = yargs.getContext()\n\n    Object.keys(argv).forEach((key) => {\n      if (specialKeys.indexOf(key) === -1 &&\n        !positionalMap.hasOwnProperty(key) &&\n        !yargs._getParseContext().hasOwnProperty(key) &&\n        !self.isValidAndSomeAliasIsNotNew(key, aliases)\n      ) {\n        unknown.push(key)\n      }\n    })\n\n    if ((currentContext.commands.length > 0) || (commandKeys.length > 0)) {\n      argv._.slice(currentContext.commands.length).forEach((key) => {\n        if (commandKeys.indexOf(key) === -1) {\n          unknown.push(key)\n        }\n      })\n    }\n\n    if (unknown.length > 0) {\n      usage.fail(__n(\n        'Unknown argument: %s',\n        'Unknown arguments: %s',\n        unknown.length,\n        unknown.join(', ')\n      ))\n    }\n  }\n\n  // check for a key that is not an alias, or for which every alias is new,\n  // implying that it was invented by the parser, e.g., during camelization\n  self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew (key, aliases) {\n    if (!aliases.hasOwnProperty(key)) {\n      return false\n    }\n    const newAliases = yargs.parsed.newAliases\n    for (let a of [key, ...aliases[key]]) {\n      if (!newAliases.hasOwnProperty(a) || !newAliases[key]) {\n        return true\n      }\n    }\n    return false\n  }\n\n  // validate arguments limited to enumerated choices\n  self.limitedChoices = function limitedChoices (argv) {\n    const options = yargs.getOptions()\n    const invalid = {}\n\n    if (!Object.keys(options.choices).length) return\n\n    Object.keys(argv).forEach((key) => {\n      if (specialKeys.indexOf(key) === -1 &&\n        options.choices.hasOwnProperty(key)) {\n        [].concat(argv[key]).forEach((value) => {\n          // TODO case-insensitive configurability\n          if (options.choices[key].indexOf(value) === -1 &&\n              value !== undefined) {\n            invalid[key] = (invalid[key] || []).concat(value)\n          }\n        })\n      }\n    })\n\n    const invalidKeys = Object.keys(invalid)\n\n    if (!invalidKeys.length) return\n\n    let msg = __('Invalid values:')\n    invalidKeys.forEach((key) => {\n      msg += `\\n  ${__(\n        'Argument: %s, Given: %s, Choices: %s',\n        key,\n        usage.stringifiedValues(invalid[key]),\n        usage.stringifiedValues(options.choices[key])\n      )}`\n    })\n    usage.fail(msg)\n  }\n\n  // custom checks, added using the `check` option on yargs.\n  let checks = []\n  self.check = function check (f, global) {\n    checks.push({\n      func: f,\n      global\n    })\n  }\n\n  self.customChecks = function customChecks (argv, aliases) {\n    for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n      const func = f.func\n      let result = null\n      try {\n        result = func(argv, aliases)\n      } catch (err) {\n        usage.fail(err.message ? err.message : err, err)\n        continue\n      }\n\n      if (!result) {\n        usage.fail(__('Argument check failed: %s', func.toString()))\n      } else if (typeof result === 'string' || result instanceof Error) {\n        usage.fail(result.toString(), result)\n      }\n    }\n  }\n\n  // check implications, argument foo implies => argument bar.\n  let implied = {}\n  self.implies = function implies (key, value) {\n    argsert('<string|object> [array|number|string]', [key, value], arguments.length)\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach((k) => {\n        self.implies(k, key[k])\n      })\n    } else {\n      yargs.global(key)\n      if (!implied[key]) {\n        implied[key] = []\n      }\n      if (Array.isArray(value)) {\n        value.forEach((i) => self.implies(key, i))\n      } else {\n        implied[key].push(value)\n      }\n    }\n  }\n  self.getImplied = function getImplied () {\n    return implied\n  }\n\n  function keyExists (argv, val) {\n    // convert string '1' to number 1\n    let num = Number(val)\n    val = isNaN(num) ? val : num\n\n    if (typeof val === 'number') {\n      // check length of argv._\n      val = argv._.length >= val\n    } else if (val.match(/^--no-.+/)) {\n      // check if key/value doesn't exist\n      val = val.match(/^--no-(.+)/)[1]\n      val = !argv[val]\n    } else {\n      // check if key/value exists\n      val = argv[val]\n    }\n    return val\n  }\n\n  self.implications = function implications (argv) {\n    const implyFail = []\n\n    Object.keys(implied).forEach((key) => {\n      const origKey = key\n      ;(implied[key] || []).forEach((value) => {\n        let key = origKey\n        const origValue = value\n        key = keyExists(argv, key)\n        value = keyExists(argv, value)\n\n        if (key && !value) {\n          implyFail.push(` ${origKey} -> ${origValue}`)\n        }\n      })\n    })\n\n    if (implyFail.length) {\n      let msg = `${__('Implications failed:')}\\n`\n\n      implyFail.forEach((value) => {\n        msg += (value)\n      })\n\n      usage.fail(msg)\n    }\n  }\n\n  let conflicting = {}\n  self.conflicts = function conflicts (key, value) {\n    argsert('<string|object> [array|string]', [key, value], arguments.length)\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach((k) => {\n        self.conflicts(k, key[k])\n      })\n    } else {\n      yargs.global(key)\n      if (!conflicting[key]) {\n        conflicting[key] = []\n      }\n      if (Array.isArray(value)) {\n        value.forEach((i) => self.conflicts(key, i))\n      } else {\n        conflicting[key].push(value)\n      }\n    }\n  }\n  self.getConflicting = () => conflicting\n\n  self.conflicting = function conflictingFn (argv) {\n    Object.keys(argv).forEach((key) => {\n      if (conflicting[key]) {\n        conflicting[key].forEach((value) => {\n          // we default keys to 'undefined' that have been configured, we should not\n          // apply conflicting check unless they are a value other than 'undefined'.\n          if (value && argv[key] !== undefined && argv[value] !== undefined) {\n            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value))\n          }\n        })\n      }\n    })\n  }\n\n  self.recommendCommands = function recommendCommands (cmd, potentialCommands) {\n    const distance = require('./levenshtein')\n    const threshold = 3 // if it takes more than three edits, let's move on.\n    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length)\n\n    let recommended = null\n    let bestDistance = Infinity\n    for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n      const d = distance(cmd, candidate)\n      if (d <= threshold && d < bestDistance) {\n        bestDistance = d\n        recommended = candidate\n      }\n    }\n    if (recommended) usage.fail(__('Did you mean %s?', recommended))\n  }\n\n  self.reset = function reset (localLookup) {\n    implied = objFilter(implied, (k, v) => !localLookup[k])\n    conflicting = objFilter(conflicting, (k, v) => !localLookup[k])\n    checks = checks.filter(c => c.global)\n    return self\n  }\n\n  let frozens = []\n  self.freeze = function freeze () {\n    let frozen = {}\n    frozens.push(frozen)\n    frozen.implied = implied\n    frozen.checks = checks\n    frozen.conflicting = conflicting\n  }\n  self.unfreeze = function unfreeze () {\n    let frozen = frozens.pop()\n    implied = frozen.implied\n    checks = frozen.checks\n    conflicting = frozen.conflicting\n  }\n\n  return self\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}