{"ast":null,"code":"'use strict';\n\nconst inspect = require('util').inspect;\n\nconst isPromise = require('./is-promise');\n\nconst {\n  applyMiddleware,\n  commandMiddlewareFactory\n} = require('./middleware');\n\nconst path = require('path');\n\nconst Parser = require('yargs-parser');\n\nconst DEFAULT_MARKER = /(^\\*)|(^\\$0)/; // handles parsing positional arguments,\n// and populating argv with said positional\n// arguments.\n\nmodule.exports = function command(yargs, usage, validation, globalMiddleware) {\n  const self = {};\n  let handlers = {};\n  let aliasMap = {};\n  let defaultCommand;\n  globalMiddleware = globalMiddleware || [];\n\n  self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware) {\n    let aliases = [];\n    const middlewares = commandMiddlewareFactory(commandMiddleware);\n\n    handler = handler || (() => {});\n\n    if (Array.isArray(cmd)) {\n      aliases = cmd.slice(1);\n      cmd = cmd[0];\n    } else if (typeof cmd === 'object') {\n      let command = Array.isArray(cmd.command) || typeof cmd.command === 'string' ? cmd.command : moduleName(cmd);\n      if (cmd.aliases) command = [].concat(command).concat(cmd.aliases);\n      self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares);\n      return;\n    } // allow a module to be provided instead of separate builder and handler\n\n\n    if (typeof builder === 'object' && builder.builder && typeof builder.handler === 'function') {\n      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares);\n      return;\n    } // parse positionals out of cmd string\n\n\n    const parsedCommand = self.parseCommand(cmd); // remove positional args from aliases only\n\n    aliases = aliases.map(alias => self.parseCommand(alias).cmd); // check for default and filter out '*''\n\n    let isDefault = false;\n    const parsedAliases = [parsedCommand.cmd].concat(aliases).filter(c => {\n      if (DEFAULT_MARKER.test(c)) {\n        isDefault = true;\n        return false;\n      }\n\n      return true;\n    }); // standardize on $0 for default command.\n\n    if (parsedAliases.length === 0 && isDefault) parsedAliases.push('$0'); // shift cmd and aliases after filtering out '*'\n\n    if (isDefault) {\n      parsedCommand.cmd = parsedAliases[0];\n      aliases = parsedAliases.slice(1);\n      cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);\n    } // populate aliasMap\n\n\n    aliases.forEach(alias => {\n      aliasMap[alias] = parsedCommand.cmd;\n    });\n\n    if (description !== false) {\n      usage.command(cmd, description, isDefault, aliases);\n    }\n\n    handlers[parsedCommand.cmd] = {\n      original: cmd,\n      description: description,\n      handler,\n      builder: builder || {},\n      middlewares: middlewares || [],\n      demanded: parsedCommand.demanded,\n      optional: parsedCommand.optional\n    };\n    if (isDefault) defaultCommand = handlers[parsedCommand.cmd];\n  };\n\n  self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {\n    opts = opts || {}; // disable recursion to support nested directories of subcommands\n\n    if (typeof opts.recurse !== 'boolean') opts.recurse = false; // exclude 'json', 'coffee' from require-directory defaults\n\n    if (!Array.isArray(opts.extensions)) opts.extensions = ['js']; // allow consumer to define their own visitor function\n\n    const parentVisit = typeof opts.visit === 'function' ? opts.visit : o => o; // call addHandler via visitor function\n\n    opts.visit = function visit(obj, joined, filename) {\n      const visited = parentVisit(obj, joined, filename); // allow consumer to skip modules with their own visitor\n\n      if (visited) {\n        // check for cyclic reference\n        // each command file path should only be seen once per execution\n        if (~context.files.indexOf(joined)) return visited; // keep track of visited files in context.files\n\n        context.files.push(joined);\n        self.addHandler(visited);\n      }\n\n      return visited;\n    };\n\n    require('require-directory')({\n      require: req,\n      filename: callerFile\n    }, dir, opts);\n  }; // lookup module object from require()d command and derive name\n  // if module was not require()d and no name given, throw error\n\n\n  function moduleName(obj) {\n    const mod = require('which-module')(obj);\n\n    if (!mod) throw new Error(`No command name given for module: ${inspect(obj)}`);\n    return commandFromFilename(mod.filename);\n  } // derive command name from filename\n\n\n  function commandFromFilename(filename) {\n    return path.basename(filename, path.extname(filename));\n  }\n\n  function extractDesc(obj) {\n    for (let keys = ['describe', 'description', 'desc'], i = 0, l = keys.length, test; i < l; i++) {\n      test = obj[keys[i]];\n      if (typeof test === 'string' || typeof test === 'boolean') return test;\n    }\n\n    return false;\n  }\n\n  self.parseCommand = function parseCommand(cmd) {\n    const extraSpacesStrippedCommand = cmd.replace(/\\s{2,}/g, ' ');\n    const splitCommand = extraSpacesStrippedCommand.split(/\\s+(?![^[]*]|[^<]*>)/);\n    const bregex = /\\.*[\\][<>]/g;\n    const parsedCommand = {\n      cmd: splitCommand.shift().replace(bregex, ''),\n      demanded: [],\n      optional: []\n    };\n    splitCommand.forEach((cmd, i) => {\n      let variadic = false;\n      cmd = cmd.replace(/\\s/g, '');\n      if (/\\.+[\\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true;\n\n      if (/^\\[/.test(cmd)) {\n        parsedCommand.optional.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic\n        });\n      } else {\n        parsedCommand.demanded.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic\n        });\n      }\n    });\n    return parsedCommand;\n  };\n\n  self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));\n\n  self.getCommandHandlers = () => handlers;\n\n  self.hasDefaultCommand = () => !!defaultCommand;\n\n  self.runCommand = function runCommand(command, yargs, parsed, commandIndex) {\n    let aliases = parsed.aliases;\n    const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;\n    const currentContext = yargs.getContext();\n    let numFiles = currentContext.files.length;\n    const parentCommands = currentContext.commands.slice(); // what does yargs look like after the builder is run?\n\n    let innerArgv = parsed.argv;\n    let innerYargs = null;\n    let positionalMap = {};\n\n    if (command) {\n      currentContext.commands.push(command);\n      currentContext.fullCommands.push(commandHandler.original);\n    }\n\n    if (typeof commandHandler.builder === 'function') {\n      // a function can be provided, which builds\n      // up a yargs chain and possibly returns it.\n      innerYargs = commandHandler.builder(yargs.reset(parsed.aliases));\n\n      if (!innerYargs || typeof innerYargs._parseArgs !== 'function') {\n        innerYargs = yargs;\n      }\n\n      if (shouldUpdateUsage(innerYargs)) {\n        innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n      }\n\n      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n      aliases = innerYargs.parsed.aliases;\n    } else if (typeof commandHandler.builder === 'object') {\n      // as a short hand, an object can instead be provided, specifying\n      // the options that a command takes.\n      innerYargs = yargs.reset(parsed.aliases);\n\n      if (shouldUpdateUsage(innerYargs)) {\n        innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n      }\n\n      Object.keys(commandHandler.builder).forEach(key => {\n        innerYargs.option(key, commandHandler.builder[key]);\n      });\n      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n      aliases = innerYargs.parsed.aliases;\n    }\n\n    if (!yargs._hasOutput()) {\n      positionalMap = populatePositionals(commandHandler, innerArgv, currentContext, yargs);\n    }\n\n    const middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares || []);\n    applyMiddleware(innerArgv, yargs, middlewares, true); // we apply validation post-hoc, so that custom\n    // checks get passed populated positional arguments.\n\n    if (!yargs._hasOutput()) yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error);\n\n    if (commandHandler.handler && !yargs._hasOutput()) {\n      yargs._setHasOutput(); // to simplify the parsing of positionals in commands,\n      // we temporarily populate '--' rather than _, with arguments\n\n\n      const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];\n      if (!populateDoubleDash) yargs._copyDoubleDash(innerArgv);\n      innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);\n      let handlerResult;\n\n      if (isPromise(innerArgv)) {\n        handlerResult = innerArgv.then(argv => commandHandler.handler(argv));\n      } else {\n        handlerResult = commandHandler.handler(innerArgv);\n      }\n\n      if (isPromise(handlerResult)) {\n        yargs.getUsageInstance().cacheHelpMessage();\n        handlerResult.catch(error => {\n          try {\n            yargs.getUsageInstance().fail(null, error);\n          } catch (err) {// fail's throwing would cause an unhandled rejection.\n          }\n        });\n      }\n    }\n\n    if (command) {\n      currentContext.commands.pop();\n      currentContext.fullCommands.pop();\n    }\n\n    numFiles = currentContext.files.length - numFiles;\n    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles);\n    return innerArgv;\n  };\n\n  function shouldUpdateUsage(yargs) {\n    return !yargs.getUsageInstance().getUsageDisabled() && yargs.getUsageInstance().getUsage().length === 0;\n  }\n\n  function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {\n    const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original;\n    const pc = parentCommands.filter(c => {\n      return !DEFAULT_MARKER.test(c);\n    });\n    pc.push(c);\n    return `$0 ${pc.join(' ')}`;\n  }\n\n  self.runDefaultBuilderOn = function (yargs) {\n    if (shouldUpdateUsage(yargs)) {\n      // build the root-level command string from the default string.\n      const commandString = DEFAULT_MARKER.test(defaultCommand.original) ? defaultCommand.original : defaultCommand.original.replace(/^[^[\\]<>]*/, '$0 ');\n      yargs.getUsageInstance().usage(commandString, defaultCommand.description);\n    }\n\n    const builder = defaultCommand.builder;\n\n    if (typeof builder === 'function') {\n      builder(yargs);\n    } else {\n      Object.keys(builder).forEach(key => {\n        yargs.option(key, builder[key]);\n      });\n    }\n  }; // transcribe all positional arguments \"command <foo> <bar> [apple]\"\n  // onto argv.\n\n\n  function populatePositionals(commandHandler, argv, context, yargs) {\n    argv._ = argv._.slice(context.commands.length); // nuke the current commands\n\n    const demanded = commandHandler.demanded.slice(0);\n    const optional = commandHandler.optional.slice(0);\n    const positionalMap = {};\n    validation.positionalCount(demanded.length, argv._.length);\n\n    while (demanded.length) {\n      const demand = demanded.shift();\n      populatePositional(demand, argv, positionalMap);\n    }\n\n    while (optional.length) {\n      const maybe = optional.shift();\n      populatePositional(maybe, argv, positionalMap);\n    }\n\n    argv._ = context.commands.concat(argv._);\n    postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));\n    return positionalMap;\n  }\n\n  function populatePositional(positional, argv, positionalMap, parseOptions) {\n    const cmd = positional.cmd[0];\n\n    if (positional.variadic) {\n      positionalMap[cmd] = argv._.splice(0).map(String);\n    } else {\n      if (argv._.length) positionalMap[cmd] = [String(argv._.shift())];\n    }\n  } // we run yargs-parser against the positional arguments\n  // applying the same parsing logic used for flags.\n\n\n  function postProcessPositionals(argv, positionalMap, parseOptions) {\n    // combine the parsing hints we've inferred from the command\n    // string with explicitly configured parsing hints.\n    const options = Object.assign({}, yargs.getOptions());\n    options.default = Object.assign(parseOptions.default, options.default);\n    options.alias = Object.assign(parseOptions.alias, options.alias);\n    options.array = options.array.concat(parseOptions.array);\n    delete options.config; //  don't load config when processing positionals.\n\n    const unparsed = [];\n    Object.keys(positionalMap).forEach(key => {\n      positionalMap[key].map(value => {\n        unparsed.push(`--${key}`);\n        unparsed.push(value);\n      });\n    }); // short-circuit parse.\n\n    if (!unparsed.length) return;\n    const config = Object.assign({}, options.configuration, {\n      'populate--': true\n    });\n    const parsed = Parser.detailed(unparsed, Object.assign({}, options, {\n      configuration: config\n    }));\n\n    if (parsed.error) {\n      yargs.getUsageInstance().fail(parsed.error.message, parsed.error);\n    } else {\n      // only copy over positional keys (don't overwrite\n      // flag arguments that were already parsed).\n      const positionalKeys = Object.keys(positionalMap);\n      Object.keys(positionalMap).forEach(key => {\n        [].push.apply(positionalKeys, parsed.aliases[key]);\n      });\n      Object.keys(parsed.argv).forEach(key => {\n        if (positionalKeys.indexOf(key) !== -1) {\n          // any new aliases need to be placed in positionalMap, which\n          // is used for validation.\n          if (!positionalMap[key]) positionalMap[key] = parsed.argv[key];\n          argv[key] = parsed.argv[key];\n        }\n      });\n    }\n  }\n\n  self.cmdToParseOptions = function (cmdString) {\n    const parseOptions = {\n      array: [],\n      default: {},\n      alias: {},\n      demand: {}\n    };\n    const parsed = self.parseCommand(cmdString);\n    parsed.demanded.forEach(d => {\n      const cmds = d.cmd.slice(0);\n      const cmd = cmds.shift();\n\n      if (d.variadic) {\n        parseOptions.array.push(cmd);\n        parseOptions.default[cmd] = [];\n      }\n\n      cmds.forEach(c => {\n        parseOptions.alias[cmd] = c;\n      });\n      parseOptions.demand[cmd] = true;\n    });\n    parsed.optional.forEach(o => {\n      const cmds = o.cmd.slice(0);\n      const cmd = cmds.shift();\n\n      if (o.variadic) {\n        parseOptions.array.push(cmd);\n        parseOptions.default[cmd] = [];\n      }\n\n      cmds.forEach(c => {\n        parseOptions.alias[cmd] = c;\n      });\n    });\n    return parseOptions;\n  };\n\n  self.reset = () => {\n    handlers = {};\n    aliasMap = {};\n    defaultCommand = undefined;\n    return self;\n  }; // used by yargs.parse() to freeze\n  // the state of commands such that\n  // we can apply .parse() multiple times\n  // with the same yargs instance.\n\n\n  let frozens = [];\n\n  self.freeze = () => {\n    let frozen = {};\n    frozens.push(frozen);\n    frozen.handlers = handlers;\n    frozen.aliasMap = aliasMap;\n    frozen.defaultCommand = defaultCommand;\n  };\n\n  self.unfreeze = () => {\n    let frozen = frozens.pop();\n    handlers = frozen.handlers;\n    aliasMap = frozen.aliasMap;\n    defaultCommand = frozen.defaultCommand;\n  };\n\n  return self;\n};","map":{"version":3,"names":["inspect","require","isPromise","applyMiddleware","commandMiddlewareFactory","path","Parser","DEFAULT_MARKER","module","exports","command","yargs","usage","validation","globalMiddleware","self","handlers","aliasMap","defaultCommand","addHandler","cmd","description","builder","handler","commandMiddleware","aliases","middlewares","Array","isArray","slice","moduleName","concat","extractDesc","parsedCommand","parseCommand","map","alias","isDefault","parsedAliases","filter","c","test","length","push","replace","forEach","original","demanded","optional","addDirectory","dir","context","req","callerFile","opts","recurse","extensions","parentVisit","visit","o","obj","joined","filename","visited","files","indexOf","mod","Error","commandFromFilename","basename","extname","keys","i","l","extraSpacesStrippedCommand","splitCommand","split","bregex","shift","variadic","getCommands","Object","getCommandHandlers","hasDefaultCommand","runCommand","parsed","commandIndex","commandHandler","currentContext","getContext","numFiles","parentCommands","commands","innerArgv","argv","innerYargs","positionalMap","fullCommands","reset","_parseArgs","shouldUpdateUsage","getUsageInstance","usageFromParentCommandsCommandHandler","key","option","_hasOutput","populatePositionals","_runValidation","error","_setHasOutput","populateDoubleDash","getOptions","configuration","_copyDoubleDash","handlerResult","then","cacheHelpMessage","catch","fail","err","pop","splice","getUsageDisabled","getUsage","trim","pc","join","runDefaultBuilderOn","commandString","_","positionalCount","demand","populatePositional","maybe","postProcessPositionals","cmdToParseOptions","positional","parseOptions","String","options","assign","default","array","config","unparsed","value","detailed","message","positionalKeys","apply","cmdString","d","cmds","undefined","frozens","freeze","frozen","unfreeze"],"sources":["/home/lawrence/learn-react/react-notes-app/node_modules/yargs/lib/command.js"],"sourcesContent":["'use strict'\n\nconst inspect = require('util').inspect\nconst isPromise = require('./is-promise')\nconst { applyMiddleware, commandMiddlewareFactory } = require('./middleware')\nconst path = require('path')\nconst Parser = require('yargs-parser')\n\nconst DEFAULT_MARKER = /(^\\*)|(^\\$0)/\n\n// handles parsing positional arguments,\n// and populating argv with said positional\n// arguments.\nmodule.exports = function command (yargs, usage, validation, globalMiddleware) {\n  const self = {}\n  let handlers = {}\n  let aliasMap = {}\n  let defaultCommand\n  globalMiddleware = globalMiddleware || []\n\n  self.addHandler = function addHandler (cmd, description, builder, handler, commandMiddleware) {\n    let aliases = []\n    const middlewares = commandMiddlewareFactory(commandMiddleware)\n    handler = handler || (() => {})\n\n    if (Array.isArray(cmd)) {\n      aliases = cmd.slice(1)\n      cmd = cmd[0]\n    } else if (typeof cmd === 'object') {\n      let command = (Array.isArray(cmd.command) || typeof cmd.command === 'string') ? cmd.command : moduleName(cmd)\n      if (cmd.aliases) command = [].concat(command).concat(cmd.aliases)\n      self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares)\n      return\n    }\n\n    // allow a module to be provided instead of separate builder and handler\n    if (typeof builder === 'object' && builder.builder && typeof builder.handler === 'function') {\n      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares)\n      return\n    }\n\n    // parse positionals out of cmd string\n    const parsedCommand = self.parseCommand(cmd)\n\n    // remove positional args from aliases only\n    aliases = aliases.map(alias => self.parseCommand(alias).cmd)\n\n    // check for default and filter out '*''\n    let isDefault = false\n    const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c) => {\n      if (DEFAULT_MARKER.test(c)) {\n        isDefault = true\n        return false\n      }\n      return true\n    })\n\n    // standardize on $0 for default command.\n    if (parsedAliases.length === 0 && isDefault) parsedAliases.push('$0')\n\n    // shift cmd and aliases after filtering out '*'\n    if (isDefault) {\n      parsedCommand.cmd = parsedAliases[0]\n      aliases = parsedAliases.slice(1)\n      cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd)\n    }\n\n    // populate aliasMap\n    aliases.forEach((alias) => {\n      aliasMap[alias] = parsedCommand.cmd\n    })\n\n    if (description !== false) {\n      usage.command(cmd, description, isDefault, aliases)\n    }\n\n    handlers[parsedCommand.cmd] = {\n      original: cmd,\n      description: description,\n      handler,\n      builder: builder || {},\n      middlewares: middlewares || [],\n      demanded: parsedCommand.demanded,\n      optional: parsedCommand.optional\n    }\n\n    if (isDefault) defaultCommand = handlers[parsedCommand.cmd]\n  }\n\n  self.addDirectory = function addDirectory (dir, context, req, callerFile, opts) {\n    opts = opts || {}\n    // disable recursion to support nested directories of subcommands\n    if (typeof opts.recurse !== 'boolean') opts.recurse = false\n    // exclude 'json', 'coffee' from require-directory defaults\n    if (!Array.isArray(opts.extensions)) opts.extensions = ['js']\n    // allow consumer to define their own visitor function\n    const parentVisit = typeof opts.visit === 'function' ? opts.visit : o => o\n    // call addHandler via visitor function\n    opts.visit = function visit (obj, joined, filename) {\n      const visited = parentVisit(obj, joined, filename)\n      // allow consumer to skip modules with their own visitor\n      if (visited) {\n        // check for cyclic reference\n        // each command file path should only be seen once per execution\n        if (~context.files.indexOf(joined)) return visited\n        // keep track of visited files in context.files\n        context.files.push(joined)\n        self.addHandler(visited)\n      }\n      return visited\n    }\n    require('require-directory')({ require: req, filename: callerFile }, dir, opts)\n  }\n\n  // lookup module object from require()d command and derive name\n  // if module was not require()d and no name given, throw error\n  function moduleName (obj) {\n    const mod = require('which-module')(obj)\n    if (!mod) throw new Error(`No command name given for module: ${inspect(obj)}`)\n    return commandFromFilename(mod.filename)\n  }\n\n  // derive command name from filename\n  function commandFromFilename (filename) {\n    return path.basename(filename, path.extname(filename))\n  }\n\n  function extractDesc (obj) {\n    for (let keys = ['describe', 'description', 'desc'], i = 0, l = keys.length, test; i < l; i++) {\n      test = obj[keys[i]]\n      if (typeof test === 'string' || typeof test === 'boolean') return test\n    }\n    return false\n  }\n\n  self.parseCommand = function parseCommand (cmd) {\n    const extraSpacesStrippedCommand = cmd.replace(/\\s{2,}/g, ' ')\n    const splitCommand = extraSpacesStrippedCommand.split(/\\s+(?![^[]*]|[^<]*>)/)\n    const bregex = /\\.*[\\][<>]/g\n    const parsedCommand = {\n      cmd: (splitCommand.shift()).replace(bregex, ''),\n      demanded: [],\n      optional: []\n    }\n    splitCommand.forEach((cmd, i) => {\n      let variadic = false\n      cmd = cmd.replace(/\\s/g, '')\n      if (/\\.+[\\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true\n      if (/^\\[/.test(cmd)) {\n        parsedCommand.optional.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic\n        })\n      } else {\n        parsedCommand.demanded.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic\n        })\n      }\n    })\n    return parsedCommand\n  }\n\n  self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap))\n\n  self.getCommandHandlers = () => handlers\n\n  self.hasDefaultCommand = () => !!defaultCommand\n\n  self.runCommand = function runCommand (command, yargs, parsed, commandIndex) {\n    let aliases = parsed.aliases\n    const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand\n    const currentContext = yargs.getContext()\n    let numFiles = currentContext.files.length\n    const parentCommands = currentContext.commands.slice()\n\n    // what does yargs look like after the builder is run?\n    let innerArgv = parsed.argv\n    let innerYargs = null\n    let positionalMap = {}\n    if (command) {\n      currentContext.commands.push(command)\n      currentContext.fullCommands.push(commandHandler.original)\n    }\n    if (typeof commandHandler.builder === 'function') {\n      // a function can be provided, which builds\n      // up a yargs chain and possibly returns it.\n      innerYargs = commandHandler.builder(yargs.reset(parsed.aliases))\n      if (!innerYargs || (typeof innerYargs._parseArgs !== 'function')) {\n        innerYargs = yargs\n      }\n      if (shouldUpdateUsage(innerYargs)) {\n        innerYargs.getUsageInstance().usage(\n          usageFromParentCommandsCommandHandler(parentCommands, commandHandler),\n          commandHandler.description\n        )\n      }\n      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex)\n      aliases = innerYargs.parsed.aliases\n    } else if (typeof commandHandler.builder === 'object') {\n      // as a short hand, an object can instead be provided, specifying\n      // the options that a command takes.\n      innerYargs = yargs.reset(parsed.aliases)\n      if (shouldUpdateUsage(innerYargs)) {\n        innerYargs.getUsageInstance().usage(\n          usageFromParentCommandsCommandHandler(parentCommands, commandHandler),\n          commandHandler.description\n        )\n      }\n      Object.keys(commandHandler.builder).forEach((key) => {\n        innerYargs.option(key, commandHandler.builder[key])\n      })\n      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex)\n      aliases = innerYargs.parsed.aliases\n    }\n\n    if (!yargs._hasOutput()) {\n      positionalMap = populatePositionals(commandHandler, innerArgv, currentContext, yargs)\n    }\n\n    const middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares || [])\n    applyMiddleware(innerArgv, yargs, middlewares, true)\n\n    // we apply validation post-hoc, so that custom\n    // checks get passed populated positional arguments.\n    if (!yargs._hasOutput()) yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error)\n\n    if (commandHandler.handler && !yargs._hasOutput()) {\n      yargs._setHasOutput()\n      // to simplify the parsing of positionals in commands,\n      // we temporarily populate '--' rather than _, with arguments\n      const populateDoubleDash = !!yargs.getOptions().configuration['populate--']\n      if (!populateDoubleDash) yargs._copyDoubleDash(innerArgv)\n\n      innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false)\n      let handlerResult\n      if (isPromise(innerArgv)) {\n        handlerResult = innerArgv.then(argv => commandHandler.handler(argv))\n      } else {\n        handlerResult = commandHandler.handler(innerArgv)\n      }\n\n      if (isPromise(handlerResult)) {\n        yargs.getUsageInstance().cacheHelpMessage()\n        handlerResult.catch(error => {\n          try {\n            yargs.getUsageInstance().fail(null, error)\n          } catch (err) {\n            // fail's throwing would cause an unhandled rejection.\n          }\n        })\n      }\n    }\n\n    if (command) {\n      currentContext.commands.pop()\n      currentContext.fullCommands.pop()\n    }\n    numFiles = currentContext.files.length - numFiles\n    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles)\n\n    return innerArgv\n  }\n\n  function shouldUpdateUsage (yargs) {\n    return !yargs.getUsageInstance().getUsageDisabled() &&\n      yargs.getUsageInstance().getUsage().length === 0\n  }\n\n  function usageFromParentCommandsCommandHandler (parentCommands, commandHandler) {\n    const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original\n    const pc = parentCommands.filter((c) => { return !DEFAULT_MARKER.test(c) })\n    pc.push(c)\n    return `$0 ${pc.join(' ')}`\n  }\n\n  self.runDefaultBuilderOn = function (yargs) {\n    if (shouldUpdateUsage(yargs)) {\n      // build the root-level command string from the default string.\n      const commandString = DEFAULT_MARKER.test(defaultCommand.original)\n        ? defaultCommand.original : defaultCommand.original.replace(/^[^[\\]<>]*/, '$0 ')\n      yargs.getUsageInstance().usage(\n        commandString,\n        defaultCommand.description\n      )\n    }\n    const builder = defaultCommand.builder\n    if (typeof builder === 'function') {\n      builder(yargs)\n    } else {\n      Object.keys(builder).forEach((key) => {\n        yargs.option(key, builder[key])\n      })\n    }\n  }\n\n  // transcribe all positional arguments \"command <foo> <bar> [apple]\"\n  // onto argv.\n  function populatePositionals (commandHandler, argv, context, yargs) {\n    argv._ = argv._.slice(context.commands.length) // nuke the current commands\n    const demanded = commandHandler.demanded.slice(0)\n    const optional = commandHandler.optional.slice(0)\n    const positionalMap = {}\n\n    validation.positionalCount(demanded.length, argv._.length)\n\n    while (demanded.length) {\n      const demand = demanded.shift()\n      populatePositional(demand, argv, positionalMap)\n    }\n\n    while (optional.length) {\n      const maybe = optional.shift()\n      populatePositional(maybe, argv, positionalMap)\n    }\n\n    argv._ = context.commands.concat(argv._)\n\n    postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original))\n\n    return positionalMap\n  }\n\n  function populatePositional (positional, argv, positionalMap, parseOptions) {\n    const cmd = positional.cmd[0]\n    if (positional.variadic) {\n      positionalMap[cmd] = argv._.splice(0).map(String)\n    } else {\n      if (argv._.length) positionalMap[cmd] = [String(argv._.shift())]\n    }\n  }\n\n  // we run yargs-parser against the positional arguments\n  // applying the same parsing logic used for flags.\n  function postProcessPositionals (argv, positionalMap, parseOptions) {\n    // combine the parsing hints we've inferred from the command\n    // string with explicitly configured parsing hints.\n    const options = Object.assign({}, yargs.getOptions())\n    options.default = Object.assign(parseOptions.default, options.default)\n    options.alias = Object.assign(parseOptions.alias, options.alias)\n    options.array = options.array.concat(parseOptions.array)\n    delete options.config //  don't load config when processing positionals.\n\n    const unparsed = []\n    Object.keys(positionalMap).forEach((key) => {\n      positionalMap[key].map((value) => {\n        unparsed.push(`--${key}`)\n        unparsed.push(value)\n      })\n    })\n\n    // short-circuit parse.\n    if (!unparsed.length) return\n\n    const config = Object.assign({}, options.configuration, {\n      'populate--': true\n    })\n    const parsed = Parser.detailed(unparsed, Object.assign({}, options, {\n      configuration: config\n    }))\n\n    if (parsed.error) {\n      yargs.getUsageInstance().fail(parsed.error.message, parsed.error)\n    } else {\n      // only copy over positional keys (don't overwrite\n      // flag arguments that were already parsed).\n      const positionalKeys = Object.keys(positionalMap)\n      Object.keys(positionalMap).forEach((key) => {\n        [].push.apply(positionalKeys, parsed.aliases[key])\n      })\n\n      Object.keys(parsed.argv).forEach((key) => {\n        if (positionalKeys.indexOf(key) !== -1) {\n          // any new aliases need to be placed in positionalMap, which\n          // is used for validation.\n          if (!positionalMap[key]) positionalMap[key] = parsed.argv[key]\n          argv[key] = parsed.argv[key]\n        }\n      })\n    }\n  }\n\n  self.cmdToParseOptions = function (cmdString) {\n    const parseOptions = {\n      array: [],\n      default: {},\n      alias: {},\n      demand: {}\n    }\n\n    const parsed = self.parseCommand(cmdString)\n    parsed.demanded.forEach((d) => {\n      const cmds = d.cmd.slice(0)\n      const cmd = cmds.shift()\n      if (d.variadic) {\n        parseOptions.array.push(cmd)\n        parseOptions.default[cmd] = []\n      }\n      cmds.forEach((c) => {\n        parseOptions.alias[cmd] = c\n      })\n      parseOptions.demand[cmd] = true\n    })\n\n    parsed.optional.forEach((o) => {\n      const cmds = o.cmd.slice(0)\n      const cmd = cmds.shift()\n      if (o.variadic) {\n        parseOptions.array.push(cmd)\n        parseOptions.default[cmd] = []\n      }\n      cmds.forEach((c) => {\n        parseOptions.alias[cmd] = c\n      })\n    })\n\n    return parseOptions\n  }\n\n  self.reset = () => {\n    handlers = {}\n    aliasMap = {}\n    defaultCommand = undefined\n    return self\n  }\n\n  // used by yargs.parse() to freeze\n  // the state of commands such that\n  // we can apply .parse() multiple times\n  // with the same yargs instance.\n  let frozens = []\n  self.freeze = () => {\n    let frozen = {}\n    frozens.push(frozen)\n    frozen.handlers = handlers\n    frozen.aliasMap = aliasMap\n    frozen.defaultCommand = defaultCommand\n  }\n  self.unfreeze = () => {\n    let frozen = frozens.pop()\n    handlers = frozen.handlers\n    aliasMap = frozen.aliasMap\n    defaultCommand = frozen.defaultCommand\n  }\n\n  return self\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}